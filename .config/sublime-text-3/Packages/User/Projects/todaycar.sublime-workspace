{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"la",
				"label"
			],
			[
				"constat",
				"constant_score"
			],
			[
				"publi",
				"publishEnd"
			],
			[
				"back",
				"background-color"
			],
			[
				"inli",
				"inline-block"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "<?php\n\nnamespace FM\\ElFinderPHP\\Driver;\n\nuse Exception;\nuse FM\\ElFinderPHP\\ElFinder;\nuse Imagick;\nuse ImagickPixel;\n\n/**\n * Base class for ElFinder volume.\n * Provide 2 layers:\n *  1. Public API (commands)\n *  2. abstract fs API\n *\n * All abstract methods begin with \"_\"\n *\n * @author Dmitry (dio) Levashov\n * @author Troex Nevelin\n * @author Alexey Sukhotin\n **/\nabstract class ElFinderVolumeDriver {\n\n    /**\n     * Request args\n     * $_POST or $_GET values\n     *\n     * @var array\n     */\n    protected $ARGS = array();\n\n    /**\n     * Driver id\n     * Must be started from letter and contains [a-z0-9]\n     * Used as part of volume id\n     *\n     * @var string\n     **/\n    protected $driverId = 'a';\n\n    /**\n     * Volume id - used as prefix for files hashes\n     *\n     * @var string\n     **/\n    protected $id = '';\n\n    /**\n     * Flag - volume \"mounted\" and available\n     *\n     * @var bool\n     **/\n    protected $mounted = false;\n\n    /**\n     * Root directory path\n     *\n     * @var string\n     **/\n    protected $root = '';\n\n    /**\n     * Root basename | alias\n     *\n     * @var string\n     **/\n    protected $rootName = '';\n\n    /**\n     * Default directory to open\n     *\n     * @var string\n     **/\n    protected $startPath = '';\n\n    /**\n     * Base URL\n     *\n     * @var string\n     **/\n    protected $URL = '';\n\n    /**\n     * Thumbnails dir path\n     *\n     * @var string\n     **/\n    protected $tmbPath = '';\n\n    /**\n     * Is thumbnails dir writable\n     *\n     * @var bool\n     **/\n    protected $tmbPathWritable = false;\n\n    /**\n     * Thumbnails base URL\n     *\n     * @var string\n     **/\n    protected $tmbURL = '';\n\n    /**\n     * Thumbnails size in px\n     *\n     * @var int\n     **/\n    protected $tmbSize = 48;\n\n    /**\n     * Image manipulation lib name\n     * auto|imagick|mogtify|gd\n     *\n     * @var string\n     **/\n    protected $imgLib = 'auto';\n\n    /**\n     * Library to crypt files name\n     *\n     * @var string\n     **/\n    protected $cryptLib = '';\n\n    /**\n     * Archivers config\n     *\n     * @var array\n     **/\n    protected $archivers = array(\n        'create'  => array(),\n        'extract' => array()\n    );\n\n    /**\n     * Server character encoding\n     *\n     * @var string or null\n     **/\n    protected $encoding = null;\n\n    /**\n     * How many subdirs levels return for tree\n     *\n     * @var int\n     **/\n    protected $treeDeep = 1;\n\n    /**\n     * Errors from last failed action\n     *\n     * @var array\n     **/\n    protected $error = array();\n\n    /**\n     * Today 24:00 timestamp\n     *\n     * @var int\n     **/\n    protected $today = 0;\n\n    /**\n     * Yesterday 24:00 timestamp\n     *\n     * @var int\n     **/\n    protected $yesterday = 0;\n\n    /**\n     * Force make dirctory on extract\n     *\n     * @var int\n     **/\n    protected $extractToNewdir = 'auto';\n\n    /**\n     * Object configuration\n     *\n     * @var array\n     **/\n    protected $options = array(\n        'id'              => '',\n        // root directory path\n        'path'            => '',\n        // open this path on initial request instead of root path\n        'startPath'       => '',\n        // how many subdirs levels return per request\n        'treeDeep'        => 1,\n        // root url, not set to disable sending URL to client (replacement for old \"fileURL\" option)\n        'URL'             => '',\n        // directory separator. required by client to show paths correctly\n        'separator'       => DIRECTORY_SEPARATOR,\n        // Server character encoding (default is '': UTF-8)\n        'encoding'        => '',\n        // for convert character encoding (default is '': Not change locale)\n        'locale'          => '',\n        // URL of volume icon (16x16 pixel image file)\n        'icon'            => '',\n        // CSS Class of volume root in tree\n        'rootCssClass'    => '',\n        // Search timeout (sec)\n        'searchTimeout'   => 30,\n        // library to crypt/uncrypt files names (not implemented)\n        'cryptLib'        => '',\n        // how to detect files mimetypes. (auto/internal/finfo/mime_content_type)\n        'mimeDetect'      => 'auto',\n        // mime.types file path (for mimeDetect==internal)\n        'mimefile'        => '',\n        // mime type normalize map : Array '[ext]:[detected mime type]' => '[normalized mime]'\n        'mimeMap'         => array(\n            'md:application/x-genesis-rom' => 'text/x-markdown',\n            'md:text/plain'                => 'text/x-markdown',\n            'markdown:text/plain'          => 'text/x-markdown',\n            'css:text/x-asm'               => 'text/css'\n        ),\n        // MIME regex of send HTTP header \"Content-Disposition: inline\"\n        // '.' is allow inline of all of MIME types\n        // '$^' is not allow inline of all of MIME types\n        'dispInlineRegex' => '^(?:(?:image|text)|application/x-shockwave-flash$)',\n        // directory for thumbnails\n        'tmbPath'         => '.tmb',\n        // mode to create thumbnails dir\n        'tmbPathMode'     => 0777,\n        // thumbnails dir URL. Set it if store thumbnails outside root directory\n        'tmbURL'          => '',\n        // thumbnails size (px)\n        'tmbSize'         => 48,\n        // thumbnails crop (true - crop, false - scale image to fit thumbnail size)\n        'tmbCrop'         => true,\n        // thumbnails background color (hex #rrggbb or 'transparent')\n        'tmbBgColor'      => '#ffffff',\n        // image manipulations library\n        'imgLib'          => 'auto',\n        // Jpeg image saveing quality\n        'jpgQuality'      => 100,\n        // on paste file -  if true - old file will be replaced with new one, if false new file get name - original_name-number.ext\n        'copyOverwrite'   => true,\n        // if true - join new and old directories content on paste\n        'copyJoin'        => true,\n        // on upload -  if true - old file will be replaced with new one, if false new file get name - original_name-number.ext\n        'uploadOverwrite' => true,\n        // mimetypes allowed to upload\n        'uploadAllow'     => array(),\n        // mimetypes not allowed to upload\n        'uploadDeny'      => array(),\n        // order to proccess uploadAllow and uploadDeny options\n        'uploadOrder'     => array('deny', 'allow'),\n        // maximum upload file size. NOTE - this is size for every uploaded files\n        'uploadMaxSize'   => 0,\n        // files dates format\n        'dateFormat'      => 'j M Y H:i',\n        // files time format\n        'timeFormat'      => 'H:i',\n        // if true - every folder will be check for children folders, otherwise all folders will be marked as having subfolders\n        'checkSubfolders' => true,\n        // allow to copy from this volume to other ones?\n        'copyFrom'        => true,\n        // allow to copy from other volumes to this one?\n        'copyTo'          => true,\n        // list of commands disabled on this root\n        'disabled'        => array(),\n        // enable file owner, group & mode info, `false` to inactivate \"chmod\" command.\n        'statOwner'       => false,\n        // allow exec chmod of read-only files\n        'allowChmodReadOnly' => false,\n        // regexp or function name to validate new file name\n        'acceptedName'    => '/^[^\\.].*/', //<-- DONT touch this! Use constructor options to overwrite it!\n        // function/class method to control files permissions\n        'accessControl'   => null,\n        // some data required by access control\n        'accessControlData' => null,\n        // default permissions.\n        'defaults'     => array(\n            'read'   => true,\n            'write'  => true,\n            'locked' => false,\n            'hidden' => false\n        ),\n        // files attributes\n        'attributes'   => array(),\n        // max allowed archive files size (0 - no limit)\n        'maxArcFilesSize' => 0,\n        // Allowed archive's mimetypes to create. Leave empty for all available types.\n        'archiveMimes' => array(),\n        // Manual config for archivers. See example below. Leave empty for auto detect\n        'archivers'    => array(),\n        // plugin settings\n        'plugin'       => array(),\n        // Is support parent directory time stamp update on add|remove|rename item\n        // Default `null` is auto detection that is LocalFileSystem, FTP or Dropbox are `true`\n        'syncChkAsTs'  => null,\n        // Long pooling sync checker function for syncChkAsTs is true\n        // Calls with args (TARGET DIRCTORY PATH, STAND-BY(sec), OLD TIMESTAMP, VOLUME DRIVER INSTANCE, ElFinder INSTANCE)\n        // This function must return the following values. Changed: New Timestamp or Same: Old Timestamp or Error: false\n        // Default `null` is try use ElFinderVolumeLocalFileSystem::localFileSystemInotify() on LocalFileSystem driver\n        // another driver use ElFinder stat() checker\n        'syncCheckFunc'=> null,\n        // Long polling sync stand-by time (sec)\n        'plStandby'    => 30,\n        // Sleep time (sec) for ElFinder stat() checker (syncChkAsTs is true)\n        'tsPlSleep'    => 10,\n        // Sleep time (sec) for ElFinder ls() checker (syncChkAsTs is false)\n        'lsPlSleep'    => 30,\n        // Client side sync interval minimum (ms)\n        // Default `null` is auto set to ('tsPlSleep' or 'lsPlSleep') * 1000\n        // `0` to disable auto sync\n        'syncMinMs'    => null,\n        // required to fix bug on macos\n        'utf8fix'      => false,\n        //                           й                 ё              Й               Ё              Ø         Å\n        'utf8patterns' => array(\"\\u0438\\u0306\", \"\\u0435\\u0308\", \"\\u0418\\u0306\", \"\\u0415\\u0308\", \"\\u00d8A\", \"\\u030a\"),\n        'utf8replace'  => array(\"\\u0439\",        \"\\u0451\",       \"\\u0419\",       \"\\u0401\",       \"\\u00d8\", \"\\u00c5\")\n    );\n\n    /**\n     * Defaults permissions\n     *\n     * @var array\n     **/\n    protected $defaults = array(\n        'read'   => true,\n        'write'  => true,\n        'locked' => false,\n        'hidden' => false\n    );\n\n    /**\n     * Access control function/class\n     *\n     * @var mixed\n     **/\n    protected $attributes = array();\n\n    /**\n     * Access control function/class\n     *\n     * @var mixed\n     **/\n    protected $access = null;\n\n    /**\n     * Mime types allowed to upload\n     *\n     * @var array\n     **/\n    protected $uploadAllow = array();\n\n    /**\n     * Mime types denied to upload\n     *\n     * @var array\n     **/\n    protected $uploadDeny = array();\n\n    /**\n     * Order to validate uploadAllow and uploadDeny\n     *\n     * @var array\n     **/\n    protected $uploadOrder = array();\n\n    /**\n     * Maximum allowed upload file size.\n     * Set as number or string with unit - \"10M\", \"500K\", \"1G\"\n     *\n     * @var int|string\n     **/\n    protected $uploadMaxSize = 0;\n\n    /**\n     * Mimetype detect method\n     *\n     * @var string\n     **/\n    protected $mimeDetect = 'auto';\n\n    /**\n     * Flag - mimetypes from externail file was loaded\n     *\n     * @var bool\n     **/\n    private static $mimetypesLoaded = false;\n\n    /**\n     * Finfo object for mimeDetect == 'finfo'\n     *\n     * @var object\n     **/\n    protected $finfo = null;\n\n    /**\n     * List of disabled client's commands\n     *\n     * @var array\n     **/\n    protected $disabled = array();\n\n    /**\n     * default extensions/mimetypes for mimeDetect == 'internal'\n     *\n     * @var array\n     **/\n    protected static $mimetypes = array(\n        // applications\n        'ai'    => 'application/postscript',\n        'eps'   => 'application/postscript',\n        'exe'   => 'application/x-executable',\n        'doc'   => 'application/msword',\n        'dot'   => 'application/msword',\n        'xls'   => 'application/vnd.ms-excel',\n        'xlt'   => 'application/vnd.ms-excel',\n        'xla'   => 'application/vnd.ms-excel',\n        'ppt'   => 'application/vnd.ms-powerpoint',\n        'pps'   => 'application/vnd.ms-powerpoint',\n        'pdf'   => 'application/pdf',\n        'xml'   => 'application/xml',\n        'swf'   => 'application/x-shockwave-flash',\n        'torrent' => 'application/x-bittorrent',\n        'jar'   => 'application/x-jar',\n        // open office (finfo detect as application/zip)\n        'odt'   => 'application/vnd.oasis.opendocument.text',\n        'ott'   => 'application/vnd.oasis.opendocument.text-template',\n        'oth'   => 'application/vnd.oasis.opendocument.text-web',\n        'odm'   => 'application/vnd.oasis.opendocument.text-master',\n        'odg'   => 'application/vnd.oasis.opendocument.graphics',\n        'otg'   => 'application/vnd.oasis.opendocument.graphics-template',\n        'odp'   => 'application/vnd.oasis.opendocument.presentation',\n        'otp'   => 'application/vnd.oasis.opendocument.presentation-template',\n        'ods'   => 'application/vnd.oasis.opendocument.spreadsheet',\n        'ots'   => 'application/vnd.oasis.opendocument.spreadsheet-template',\n        'odc'   => 'application/vnd.oasis.opendocument.chart',\n        'odf'   => 'application/vnd.oasis.opendocument.formula',\n        'odb'   => 'application/vnd.oasis.opendocument.database',\n        'odi'   => 'application/vnd.oasis.opendocument.image',\n        'oxt'   => 'application/vnd.openofficeorg.extension',\n        // MS office 2007 (finfo detect as application/zip)\n        'docx'  => 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n        'docm'  => 'application/vnd.ms-word.document.macroEnabled.12',\n        'dotx'  => 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',\n        'dotm'  => 'application/vnd.ms-word.template.macroEnabled.12',\n        'xlsx'  => 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n        'xlsm'  => 'application/vnd.ms-excel.sheet.macroEnabled.12',\n        'xltx'  => 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',\n        'xltm'  => 'application/vnd.ms-excel.template.macroEnabled.12',\n        'xlsb'  => 'application/vnd.ms-excel.sheet.binary.macroEnabled.12',\n        'xlam'  => 'application/vnd.ms-excel.addin.macroEnabled.12',\n        'pptx'  => 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n        'pptm'  => 'application/vnd.ms-powerpoint.presentation.macroEnabled.12',\n        'ppsx'  => 'application/vnd.openxmlformats-officedocument.presentationml.slideshow',\n        'ppsm'  => 'application/vnd.ms-powerpoint.slideshow.macroEnabled.12',\n        'potx'  => 'application/vnd.openxmlformats-officedocument.presentationml.template',\n        'potm'  => 'application/vnd.ms-powerpoint.template.macroEnabled.12',\n        'ppam'  => 'application/vnd.ms-powerpoint.addin.macroEnabled.12',\n        'sldx'  => 'application/vnd.openxmlformats-officedocument.presentationml.slide',\n        'sldm'  => 'application/vnd.ms-powerpoint.slide.macroEnabled.12',\n        // archives\n        'gz'    => 'application/x-gzip',\n        'tgz'   => 'application/x-gzip',\n        'bz'    => 'application/x-bzip2',\n        'bz2'   => 'application/x-bzip2',\n        'tbz'   => 'application/x-bzip2',\n        'xz'    => 'application/x-xz',\n        'zip'   => 'application/zip',\n        'rar'   => 'application/x-rar',\n        'tar'   => 'application/x-tar',\n        '7z'    => 'application/x-7z-compressed',\n        // texts\n        'txt'   => 'text/plain',\n        'php'   => 'text/x-php',\n        'html'  => 'text/html',\n        'htm'   => 'text/html',\n        'js'    => 'text/javascript',\n        'css'   => 'text/css',\n        'rtf'   => 'text/rtf',\n        'rtfd'  => 'text/rtfd',\n        'py'    => 'text/x-python',\n        'java'  => 'text/x-java-source',\n        'rb'    => 'text/x-ruby',\n        'sh'    => 'text/x-shellscript',\n        'pl'    => 'text/x-perl',\n        'xml'   => 'text/xml',\n        'sql'   => 'text/x-sql',\n        'c'     => 'text/x-csrc',\n        'h'     => 'text/x-chdr',\n        'cpp'   => 'text/x-c++src',\n        'hh'    => 'text/x-c++hdr',\n        'log'   => 'text/plain',\n        'csv'   => 'text/x-comma-separated-values',\n        'md'    => 'text/x-markdown',\n        'markdown' => 'text/x-markdown',\n        // images\n        'bmp'   => 'image/x-ms-bmp',\n        'jpg'   => 'image/jpeg',\n        'jpeg'  => 'image/jpeg',\n        'gif'   => 'image/gif',\n        'png'   => 'image/png',\n        'tif'   => 'image/tiff',\n        'tiff'  => 'image/tiff',\n        'tga'   => 'image/x-targa',\n        'psd'   => 'image/vnd.adobe.photoshop',\n        'ai'    => 'image/vnd.adobe.photoshop',\n        'xbm'   => 'image/xbm',\n        'pxm'   => 'image/pxm',\n        //audio\n        'mp3'   => 'audio/mpeg',\n        'mid'   => 'audio/midi',\n        'ogg'   => 'audio/ogg',\n        'oga'   => 'audio/ogg',\n        'm4a'   => 'audio/x-m4a',\n        'wav'   => 'audio/wav',\n        'wma'   => 'audio/x-ms-wma',\n        // video\n        'avi'   => 'video/x-msvideo',\n        'dv'    => 'video/x-dv',\n        'mp4'   => 'video/mp4',\n        'mpeg'  => 'video/mpeg',\n        'mpg'   => 'video/mpeg',\n        'mov'   => 'video/quicktime',\n        'wm'    => 'video/x-ms-wmv',\n        'flv'   => 'video/x-flv',\n        'mkv'   => 'video/x-matroska',\n        'webm'  => 'video/webm',\n        'ogv'   => 'video/ogg',\n        'ogm'   => 'video/ogg'\n    );\n\n    /**\n     * Directory separator - required by client\n     *\n     * @var string\n     **/\n    protected $separator = DIRECTORY_SEPARATOR;\n\n    /**\n     * System Root path (Unix like: '/', Windows: '\\', 'C:\\' or 'D:\\'...)\n     *\n     * @var string\n     **/\n    protected $systemRoot = DIRECTORY_SEPARATOR;\n\n    /**\n     * Mimetypes allowed to display\n     *\n     * @var array\n     **/\n    protected $onlyMimes = array();\n\n    /**\n     * Store files moved or overwrited files info\n     *\n     * @var array\n     **/\n    protected $removed = array();\n\n    /**\n     * Cache storage\n     *\n     * @var array\n     **/\n    protected $cache = array();\n\n    /**\n     * Cache by folders\n     *\n     * @var array\n     **/\n    protected $dirsCache = array();\n\n    /**\n     * Cache for subdirsCE()\n     *\n     * @var array\n     */\n    protected $subdirsCache = array();\n\n    /**\n     * Reference of $_SESSION[ElFinder::$sessionCacheKey][$this->id]\n     *\n     * @var array\n     */\n    protected $sessionCache;\n\n\n    /**\n     * Search start time\n     *\n     * @var int\n     */\n    protected $searchStart;\n\n    /*********************************************************************/\n    /*                            INITIALIZATION                         */\n    /*********************************************************************/\n\n    /**\n     * Prepare driver before mount volume.\n     * Return true if volume is ready.\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function init() {\n        return true;\n    }\n\n    /**\n     * Configure after successfull mount.\n     * By default set thumbnails path and image manipulation library.\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function configure() {\n        // set ARGS\n        $this->ARGS = $_SERVER['REQUEST_METHOD'] === 'POST'? $_POST : $_GET;\n        // set thumbnails path\n        $path = $this->options['tmbPath'];\n        if ($path) {\n            if (!file_exists($path)) {\n                if (@mkdir($path)) {\n                    chmod($path, $this->options['tmbPathMode']);\n                } else {\n                    $path = '';\n                }\n            }\n\n            if (is_dir($path) && is_readable($path)) {\n                $this->tmbPath = $path;\n                $this->tmbPathWritable = is_writable($path);\n            }\n        }\n\n        // set image manipulation library\n        $type = preg_match('/^(imagick|gd|auto)$/i', $this->options['imgLib'])\n            ? strtolower($this->options['imgLib'])\n            : 'auto';\n\n        if (($type == 'imagick' || $type == 'auto') && extension_loaded('imagick')) {\n            $this->imgLib = 'imagick';\n        } else {\n            $this->imgLib = function_exists('gd_info') ? 'gd' : '';\n        }\n\n        // check archivers\n        if (empty($this->archivers['create'])) {\n            $this->disabled[] ='archive';\n        }\n        if (empty($this->archivers['extract'])) {\n            $this->disabled[] ='extract';\n        }\n        $_arc = $this->getArchivers();\n        if (empty($_arc['create'])) {\n            $this->disabled[] ='zipdl';\n        }\n\n        // check 'statOwner' for command `chmod`\n        if (empty($this->options['statOwner'])) {\n            $this->disabled[] ='chmod';\n        }\n\n        // check 'mimeMap'\n        if (!is_array($this->options['mimeMap'])) {\n            $this->options['mimeMap'] = array();\n        }\n    }\n\n    protected function sessionRestart() {\n        $start = @session_start();\n        if (!isset($_SESSION[ElFinder::$sessionCacheKey])) {\n            $_SESSION[ElFinder::$sessionCacheKey] = array();\n        }\n        $this->sessionCache = &$_SESSION[ElFinder::$sessionCacheKey][$this->id];\n        return $start;\n    }\n    /*********************************************************************/\n    /*                              PUBLIC API                           */\n    /*********************************************************************/\n\n    /**\n     * Return driver id. Used as a part of volume id.\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function driverId() {\n        return $this->driverId;\n    }\n\n    /**\n     * Return volume id\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function id() {\n        return $this->id;\n    }\n\n    /**\n     * Return debug info for client\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function debug() {\n        return array(\n            'id'         => $this->id(),\n            'name'       => strtolower(substr(get_class($this), strlen('ElFinderdriver'))),\n            'mimeDetect' => $this->mimeDetect,\n            'imgLib'     => $this->imgLib\n        );\n    }\n\n    /**\n     * chmod a file or folder\n     *\n     * @param  string   $hash    file or folder hash to chmod\n     * @param  string   $mode    octal string representing new permissions\n     * @return array|false\n     * @author David Bartle\n     **/\n    public function chmod($hash, $mode) {\n        if ($this->commandDisabled('chmod')) {\n            return $this->setError(ElFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!($file = $this->file($hash))) {\n            return $this->setError(ElFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if (!$this->options['allowChmodReadOnly']) {\n            if (!$this->attr($this->decode($hash), 'write', null, ($file['mime'] === 'directory'))) {\n                return $this->setError(ElFinder::ERROR_PERM_DENIED, $file['name']);\n            }\n        }\n\n        $path = $this->decode($hash);\n\n        if ($this->convEncOut(!$this->_chmod($this->convEncIn($path), $mode))) {\n            return $this->setError(ElFinder::ERROR_PERM_DENIED, $file['name']);\n        }\n\n        $this->clearcache();\n\n        if ($file = $this->stat($path)) {\n            $files = array($file);\n            if ($file['mime'] === 'directory' && 'write' !== $file['write']) {\n                foreach ($this->getScandir($path) as $stat) {\n                    if ($this->mimeAccepted($stat['mime'])) {\n                        $files[] = $stat;\n                    }\n                }\n            }\n            return $files;\n        } else {\n            return $this->setError(ElFinder::ERROR_FILE_NOT_FOUND);\n        }\n    }\n\n    /**\n     * stat a file or folder for ElFinder cmd exec\n     *\n     * @param  string   $hash    file or folder hash to chmod\n     * @return array\n     * @author Naoki Sawada\n     **/\n    public function fstat($hash) {\n        $path = $this->decode($hash);\n        return $this->stat($path);\n    }\n\n\n    public function clearstatcache() {\n        clearstatcache();\n        $this->cache = $this->dirsCache = array();\n    }\n\n    /**\n     * \"Mount\" volume.\n     * Return true if volume available for read or write,\n     * false - otherwise\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     **/\n    public function mount(array $opts) {\n        if (!isset($opts['path']) || $opts['path'] === '') {\n            return $this->setError('Path undefined.');;\n        }\n\n        $this->options = array_merge($this->options, $opts);\n        $this->id = $this->driverId.(!empty($this->options['id']) ? $this->options['id'] : ElFinder::$volumesCnt++).'_';\n        $this->root = $this->normpathCE($this->options['path']);\n        $this->separator = isset($this->options['separator']) ? $this->options['separator'] : DIRECTORY_SEPARATOR;\n        $this->systemRoot = isset($this->options['systemRoot']) ? $this->options['systemRoot'] : $this->separator;\n\n        // set server encoding\n        if (!empty($this->options['encoding']) && strtoupper($this->options['encoding']) !== 'UTF-8') {\n            $this->encoding = $this->options['encoding'];\n        } else {\n            $this->encoding = null;\n        }\n\n        $argInit = !empty($this->ARGS['init']);\n\n        // session cache\n        if ($argInit || ! isset($_SESSION[ElFinder::$sessionCacheKey][$this->id])) {\n            $_SESSION[ElFinder::$sessionCacheKey][$this->id] = array();\n        }\n        $this->sessionCache = &$_SESSION[ElFinder::$sessionCacheKey][$this->id];\n\n        // default file attribute\n        $this->defaults = array(\n            'read'    => isset($this->options['defaults']['read'])  ? !!$this->options['defaults']['read']  : true,\n            'write'   => isset($this->options['defaults']['write']) ? !!$this->options['defaults']['write'] : true,\n            'locked'  => isset($this->options['defaults']['locked']) ? !!$this->options['defaults']['locked'] : false,\n            'hidden'  => isset($this->options['defaults']['hidden']) ? !!$this->options['defaults']['hidden'] : false\n        );\n\n        // root attributes\n        $this->attributes[] = array(\n            'pattern' => '~^'.preg_quote(DIRECTORY_SEPARATOR).'$~',\n            'locked'  => true,\n            'hidden'  => false\n        );\n        // set files attributes\n        if (!empty($this->options['attributes']) && is_array($this->options['attributes'])) {\n\n            foreach ($this->options['attributes'] as $a) {\n                // attributes must contain pattern and at least one rule\n                if (!empty($a['pattern']) || count($a) > 1) {\n                    $this->attributes[] = $a;\n                }\n            }\n        }\n\n        if (!empty($this->options['accessControl']) && is_callable($this->options['accessControl'])) {\n            $this->access = $this->options['accessControl'];\n        }\n\n        $this->today     = mktime(0,0,0, date('m'), date('d'), date('Y'));\n        $this->yesterday = $this->today-86400;\n\n        // debug($this->attributes);\n        if (!$this->init()) {\n            return false;\n        }\n\n        // check some options is arrays\n        $this->uploadAllow = isset($this->options['uploadAllow']) && is_array($this->options['uploadAllow'])\n            ? $this->options['uploadAllow']\n            : array();\n\n        $this->uploadDeny = isset($this->options['uploadDeny']) && is_array($this->options['uploadDeny'])\n            ? $this->options['uploadDeny']\n            : array();\n\n        if (is_string($this->options['uploadOrder'])) { // telephat_mode on, compatibility with 1.x\n            $parts = explode(',', isset($this->options['uploadOrder']) ? $this->options['uploadOrder'] : 'deny,allow');\n            $this->uploadOrder = array(trim($parts[0]), trim($parts[1]));\n        } else { // telephat_mode off\n            $this->uploadOrder = $this->options['uploadOrder'];\n        }\n\n        if (!empty($this->options['uploadMaxSize'])) {\n            $size = ''.$this->options['uploadMaxSize'];\n            $unit = strtolower(substr($size, strlen($size) - 1));\n            $n = 1;\n            switch ($unit) {\n                case 'k':\n                    $n = 1024;\n                    break;\n                case 'm':\n                    $n = 1048576;\n                    break;\n                case 'g':\n                    $n = 1073741824;\n            }\n            $this->uploadMaxSize = intval($size)*$n;\n        }\n        // Set maximum to PHP_INT_MAX\n        if (!defined('PHP_INT_MAX')) {\n            define('PHP_INT_MAX', 2147483647);\n        }\n        if ($this->uploadMaxSize < 1 || $this->uploadMaxSize > PHP_INT_MAX) {\n            $this->uploadMaxSize = PHP_INT_MAX;\n        }\n\n        $this->disabled = isset($this->options['disabled']) && is_array($this->options['disabled'])\n            ? $this->options['disabled']\n            : array();\n\n        $this->cryptLib   = $this->options['cryptLib'];\n        $this->mimeDetect = $this->options['mimeDetect'];\n\n        // find available mimetype detect method\n        $type = strtolower($this->options['mimeDetect']);\n        $type = preg_match('/^(finfo|mime_content_type|internal|auto)$/i', $type) ? $type : 'auto';\n        $regexp = '/text\\/x\\-(php|c\\+\\+)/';\n\n        if (($type == 'finfo' || $type == 'auto')\n            && class_exists('finfo', false)) {\n            $tmpFileInfo = @explode(';', @finfo_file(finfo_open(FILEINFO_MIME), __FILE__));\n        } else {\n            $tmpFileInfo = false;\n        }\n\n        if ($tmpFileInfo && preg_match($regexp, array_shift($tmpFileInfo))) {\n            $type = 'finfo';\n            $this->finfo = finfo_open(FILEINFO_MIME);\n        } elseif (($type == 'mime_content_type' || $type == 'auto')\n            && function_exists('mime_content_type')\n            && preg_match($regexp, array_shift(explode(';', mime_content_type(__FILE__))))) {\n            $type = 'mime_content_type';\n        } else {\n            $type = 'internal';\n        }\n        $this->mimeDetect = $type;\n\n        // load mimes from external file for mimeDetect == 'internal'\n        // based on Alexey Sukhotin idea and patch: http://elrte.org/redmine/issues/163\n        // file must be in file directory or in parent one\n        if ($this->mimeDetect == 'internal' && !self::$mimetypesLoaded) {\n            self::$mimetypesLoaded = true;\n            $this->mimeDetect = 'internal';\n            $file = false;\n            if (!empty($this->options['mimefile']) && file_exists($this->options['mimefile'])) {\n                $file = $this->options['mimefile'];\n            } elseif (file_exists(dirname(__FILE__).DIRECTORY_SEPARATOR.'mime.types')) {\n                $file = dirname(__FILE__).DIRECTORY_SEPARATOR.'mime.types';\n            } elseif (file_exists(dirname(dirname(__FILE__)).DIRECTORY_SEPARATOR.'mime.types')) {\n                $file = dirname(dirname(__FILE__)).DIRECTORY_SEPARATOR.'mime.types';\n            }\n\n            if ($file && file_exists($file)) {\n                $mimecf = file($file);\n\n                foreach ($mimecf as $line_num => $line) {\n                    if (!preg_match('/^\\s*#/', $line)) {\n                        $mime = preg_split('/\\s+/', $line, -1, PREG_SPLIT_NO_EMPTY);\n                        for ($i = 1, $size = count($mime); $i < $size ; $i++) {\n                            if (!isset(self::$mimetypes[$mime[$i]])) {\n                                self::$mimetypes[$mime[$i]] = $mime[0];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        $this->rootName = empty($this->options['alias']) ? $this->basenameCE($this->root) : $this->options['alias'];\n\n        // This get's triggered if $this->root == '/' and alias is empty.\n        // Maybe modify _basename instead?\n        if ($this->rootName === '') $this->rootName = $this->separator;\n\n        $root = $this->stat($this->root);\n\n        if (!$root) {\n            return $this->setError('Root folder does not exists.');\n        }\n        if (!$root['read'] && !$root['write']) {\n            return $this->setError('Root folder has not read and write permissions.');\n        }\n\n        // debug($root);\n\n        if ($root['read']) {\n            // check startPath - path to open by default instead of root\n            $startPath = $this->options['startPath']? $this->normpathCE($this->options['startPath']) : '';\n            if ($startPath) {\n                $start = $this->stat($startPath);\n                if (!empty($start)\n                    && $start['mime'] == 'directory'\n                    && $start['read']\n                    && empty($start['hidden'])\n                    && $this->inpathCE($startPath, $this->root)) {\n                    $this->startPath = $startPath;\n                    if (substr($this->startPath, -1, 1) == $this->options['separator']) {\n                        $this->startPath = substr($this->startPath, 0, -1);\n                    }\n                }\n            }\n        } else {\n            $this->options['URL']     = '';\n            $this->options['tmbURL']  = '';\n            $this->options['tmbPath'] = '';\n            // read only volume\n            array_unshift($this->attributes, array(\n                'pattern' => '/.*/',\n                'read'    => false\n            ));\n        }\n        $this->treeDeep = $this->options['treeDeep'] > 0 ? (int)$this->options['treeDeep'] : 1;\n        $this->tmbSize  = $this->options['tmbSize'] > 0 ? (int)$this->options['tmbSize'] : 48;\n        $this->URL      = $this->options['URL'];\n        if ($this->URL && preg_match(\"|[^/?&=]$|\", $this->URL)) {\n            $this->URL .= '/';\n        }\n\n        $this->tmbURL   = !empty($this->options['tmbURL']) ? $this->options['tmbURL'] : '';\n        if ($this->tmbURL && preg_match(\"|[^/?&=]$|\", $this->tmbURL)) {\n            $this->tmbURL .= '/';\n        }\n\n        $this->nameValidator = !empty($this->options['acceptedName']) && (is_string($this->options['acceptedName']) || is_callable($this->options['acceptedName']))\n            ? $this->options['acceptedName']\n            : '';\n\n        $this->_checkArchivers();\n        // manual control archive types to create\n        if (!empty($this->options['archiveMimes']) && is_array($this->options['archiveMimes'])) {\n            foreach ($this->archivers['create'] as $mime => $v) {\n                if (!in_array($mime, $this->options['archiveMimes'])) {\n                    unset($this->archivers['create'][$mime]);\n                }\n            }\n        }\n\n        // manualy add archivers\n        if (!empty($this->options['archivers']['create']) && is_array($this->options['archivers']['create'])) {\n            foreach ($this->options['archivers']['create'] as $mime => $conf) {\n                if (strpos($mime, 'application/') === 0\n                    && !empty($conf['cmd'])\n                    && isset($conf['argc'])\n                    && !empty($conf['ext'])\n                    && !isset($this->archivers['create'][$mime])) {\n                    $this->archivers['create'][$mime] = $conf;\n                }\n            }\n        }\n\n        if (!empty($this->options['archivers']['extract']) && is_array($this->options['archivers']['extract'])) {\n            foreach ($this->options['archivers']['extract'] as $mime => $conf) {\n                if (strpos($mime, 'application/') === 0\n                    && !empty($conf['cmd'])\n                    && isset($conf['argc'])\n                    && !empty($conf['ext'])\n                    && !isset($this->archivers['extract'][$mime])) {\n                    $this->archivers['extract'][$mime] = $conf;\n                }\n            }\n        }\n\n        $this->configure();\n\n        // Normarize disabled (array_merge`for type array of JSON)\n        $this->disabled = array_merge(array_unique($this->disabled));\n\n        // fix sync interval\n        if ($this->options['syncMinMs'] !== 0) {\n            $this->options['syncMinMs'] = max($this->options[$this->options['syncChkAsTs']? 'tsPlSleep' : 'lsPlSleep'] * 1000, intval($this->options['syncMinMs']));\n        }\n\n        return $this->mounted = true;\n    }\n\n    /**\n     * Some \"unmount\" stuffs - may be required by virtual fs\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    public function umount() {\n    }\n\n    /**\n     * Return error message from last failed action\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function error() {\n        return $this->error;\n    }\n\n    /**\n     * Return is uploadable that given file name\n     *\n     * @param  string  $name  file name\n     * @param  bool    $allowUnknown\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    public function isUploadableByName($name, $allowUnknown = true) {\n        $mimeByName = ElFinderVolumeDriver::mimetypeInternalDetect($name);\n        return (($allowUnknown && $mimeByName === 'unknown') || $this->allowPutMime($mimeByName));\n    }\n\n    /**\n     * Return Extention/MIME Table (ElFinderVolumeDriver::$mimetypes)\n     *\n     * @return array\n     * @author Naoki Sawada\n     */\n    public function getMimeTable() {\n        return ElFinderVolumeDriver::$mimetypes;\n    }\n\n    /**\n     * Set mimetypes allowed to display to client\n     *\n     * @param  array  $mimes\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    public function setMimesFilter($mimes) {\n        if (is_array($mimes)) {\n            $this->onlyMimes = $mimes;\n        }\n    }\n\n    /**\n     * Return root folder hash\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function root() {\n        return $this->encode($this->root);\n    }\n\n    /**\n     * Return target path hash\n     *\n     * @param  string $path\n     * @param  string $name\n     * @author Naoki Sawada\n     */\n    public function getHash($path, $name = '') {\n        if ($name !== '') {\n            $path = $this->joinPathCE($path, $name);\n        }\n        return $this->encode($path);\n    }\n\n    /**\n     * Return root or startPath hash\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function defaultPath() {\n        return $this->encode($this->startPath ? $this->startPath : $this->root);\n    }\n\n    /**\n     * Return volume options required by client:\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function options($hash) {\n        $create = $createext = array();\n        if (isset($this->archivers['create']) && is_array($this->archivers['create'])) {\n            foreach($this->archivers['create'] as $m => $v) {\n                $create[] = $m;\n                $createext[$m] = $v['ext'];\n            }\n        }\n        return array(\n            'path'            => $this->path($hash),\n            'url'             => $this->URL,\n            'tmbUrl'          => $this->tmbURL,\n            'disabled'        => $this->disabled,\n            'separator'       => $this->separator,\n            'copyOverwrite'   => intval($this->options['copyOverwrite']),\n            'uploadOverwrite' => intval($this->options['uploadOverwrite']),\n            'uploadMaxSize'   => intval($this->uploadMaxSize),\n            'dispInlineRegex' => $this->options['dispInlineRegex'],\n            'jpgQuality'      => intval($this->options['jpgQuality']),\n            'archivers'       => array(\n                'create'    => $create,\n                'extract'   => isset($this->archivers['extract']) && is_array($this->archivers['extract']) ? array_keys($this->archivers['extract']) : array(),\n                'createext' => $createext\n            ),\n            'uiCmdMap'        => (isset($this->options['uiCmdMap']) && is_array($this->options['uiCmdMap']))? $this->options['uiCmdMap'] : array(),\n            'syncChkAsTs'     => intval($this->options['syncChkAsTs']),\n            'syncMinMs'       => intval($this->options['syncMinMs'])\n        );\n    }\n\n    /**\n     * Get option value of this volume\n     *\n     * @param string $name  target option name\n     * @return NULL|mixed   target option value\n     * @author Naoki Sawada\n     */\n    public function getOption($name) {\n        return isset($this->options[$name])? $this->options[$name] : null;\n    }\n\n    /**\n     * Get plugin values of this options\n     *\n     * @param string $name  Plugin name\n     * @return NULL|array   Plugin values\n     * @author Naoki Sawada\n     */\n    public function getOptionsPlugin($name = '') {\n        if ($name) {\n            return isset($this->options['plugin'][$name])? $this->options['plugin'][$name] : array();\n        } else {\n            return $this->options['plugin'];\n        }\n    }\n\n    /**\n     * Return true if command disabled in options\n     *\n     * @param  string  $cmd  command name\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    public function commandDisabled($cmd) {\n        return in_array($cmd, $this->disabled);\n    }\n\n    /**\n     * Return true if mime is required mimes list\n     *\n     * @param  string     $mime   mime type to check\n     * @param  array      $mimes  allowed mime types list or not set to use client mimes list\n     * @param  bool|null  $empty  what to return on empty list\n     * @return bool|null\n     * @author Dmitry (dio) Levashov\n     * @author Troex Nevelin\n     **/\n    public function mimeAccepted($mime, $mimes = null, $empty = true) {\n        $mimes = is_array($mimes) ? $mimes : $this->onlyMimes;\n        if (empty($mimes)) {\n            return $empty;\n        }\n        return $mime == 'directory'\n        || in_array('all', $mimes)\n        || in_array('All', $mimes)\n        || in_array($mime, $mimes)\n        || in_array(substr($mime, 0, strpos($mime, '/')), $mimes);\n    }\n\n    /**\n     * Return true if voume is readable.\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    public function isReadable() {\n        $stat = $this->stat($this->root);\n        return $stat['read'];\n    }\n\n    /**\n     * Return true if copy from this volume allowed\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    public function copyFromAllowed() {\n        return !!$this->options['copyFrom'];\n    }\n\n    /**\n     * Return file path related to root with convert encoging\n     *\n     * @param  string   $hash  file hash\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function path($hash) {\n        return $this->convEncOut($this->_path($this->convEncIn($this->decode($hash))));\n    }\n\n    /**\n     * Return file real path if file exists\n     *\n     * @param  string  $hash  file hash\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function realpath($hash) {\n        $path = $this->decode($hash);\n        return $this->stat($path) ? $path : false;\n    }\n\n    /**\n     * Return list of moved/overwrited files\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function removed() {\n        return $this->removed;\n    }\n\n    /**\n     * Clean removed files list\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    public function resetRemoved() {\n        $this->removed = array();\n    }\n\n    /**\n     * Return file/dir hash or first founded child hash with required attr == $val\n     *\n     * @param  string   $hash  file hash\n     * @param  string   $attr  attribute name\n     * @param  bool     $val   attribute value\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function closest($hash, $attr, $val) {\n        return ($path = $this->closestByAttr($this->decode($hash), $attr, $val)) ? $this->encode($path) : false;\n    }\n\n    /**\n     * Return file info or false on error\n     *\n     * @param  string   $hash      file hash\n     * @param  bool     $realpath  add realpath field to file info\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function file($hash) {\n        $path = $this->decode($hash);\n        $isRoot = ($path == $this->root);\n\n        $file = $this->stat($path);\n\n        if ($isRoot) {\n            $file = array_merge($file, $this->getRootStatExtra());\n        }\n\n        return ($file) ? $file : $this->setError(ElFinder::ERROR_FILE_NOT_FOUND);\n    }\n\n    /**\n     * Return folder info\n     *\n     * @param  string   $hash  folder hash\n     * @param  bool     $hidden  return hidden file info\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function dir($hash, $resolveLink=false) {\n        if (($dir = $this->file($hash)) == false) {\n            return $this->setError(ElFinder::ERROR_DIR_NOT_FOUND);\n        }\n\n        if ($resolveLink && !empty($dir['thash'])) {\n            $dir = $this->file($dir['thash']);\n        }\n\n        return $dir && $dir['mime'] == 'directory' && empty($dir['hidden'])\n            ? $dir\n            : $this->setError(ElFinder::ERROR_NOT_DIR);\n    }\n\n    /**\n     * Return directory content or false on error\n     *\n     * @param  string   $hash   file hash\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function scandir($hash) {\n        if (($dir = $this->dir($hash)) == false) {\n            return false;\n        }\n\n        return $dir['read']\n            ? $this->getScandir($this->decode($hash))\n            : $this->setError(ElFinder::ERROR_PERM_DENIED);\n    }\n\n    /**\n     * Return dir files names list\n     *\n     * @param  string  $hash   file hash\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function ls($hash) {\n        if (($dir = $this->dir($hash)) == false || !$dir['read']) {\n            return false;\n        }\n\n        $list = array();\n        $path = $this->decode($hash);\n\n        foreach ($this->getScandir($path) as $stat) {\n            if (empty($stat['hidden']) && $this->mimeAccepted($stat['mime'])) {\n                $list[] = $stat['name'];\n            }\n        }\n\n        return $list;\n    }\n\n    /**\n     * Return subfolders for required folder or false on error\n     *\n     * @param  string   $hash  folder hash or empty string to get tree from root folder\n     * @param  int      $deep  subdir deep\n     * @param  string   $exclude  dir hash which subfolders must be exluded from result, required to not get stat twice on cwd subfolders\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function tree($hash='', $deep=0, $exclude='') {\n        $path = $hash ? $this->decode($hash) : $this->root;\n\n        if (($dir = $this->stat($path)) == false || $dir['mime'] != 'directory') {\n            return false;\n        }\n\n        $dirs = $this->gettree($path, $deep > 0 ? $deep -1 : $this->treeDeep-1, $exclude ? $this->decode($exclude) : null);\n        array_unshift($dirs, $dir);\n        return $dirs;\n    }\n\n    /**\n     * Return part of dirs tree from required dir up to root dir\n     *\n     * @param  string    $hash   directory hash\n     * @param  bool|null $lineal only lineal parents\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function parents($hash, $lineal = false) {\n        if (($current = $this->dir($hash)) == false) {\n            return false;\n        }\n\n        $path = $this->decode($hash);\n        $tree = array();\n\n        while ($path && $path != $this->root) {\n            $path = $this->dirnameCE($path);\n            if (!($stat = $this->stat($path)) || !empty($stat['hidden']) || !$stat['read']) {\n                return false;\n            }\n\n            array_unshift($tree, $stat);\n            if (!$lineal) {\n                foreach ($this->gettree($path, 0) as $dir) {\n                    if (!in_array($dir, $tree)) {\n                        $tree[] = $dir;\n                    }\n                }\n            }\n        }\n\n        return $tree ? $tree : array($current);\n    }\n\n    /**\n     * Create thumbnail for required file and return its name of false on failed\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function tmb($hash) {\n        $path = $this->decode($hash);\n        $stat = $this->stat($path);\n\n        if (isset($stat['tmb'])) {\n            return $stat['tmb'] == \"1\" ? $this->createTmb($path, $stat) : $stat['tmb'];\n        }\n        return false;\n    }\n\n    /**\n     * Return file size / total directory size\n     *\n     * @param  string   file hash\n     * @return int\n     * @author Dmitry (dio) Levashov\n     **/\n    public function size($hash) {\n        return $this->countSize($this->decode($hash));\n    }\n\n    /**\n     * Open file for reading and return file pointer\n     *\n     * @param  string   file hash\n     * @return Resource\n     * @author Dmitry (dio) Levashov\n     **/\n    public function open($hash) {\n        if (($file = $this->file($hash)) == false\n            || $file['mime'] == 'directory') {\n            return false;\n        }\n\n        return $this->fopenCE($this->decode($hash), 'rb');\n    }\n\n    /**\n     * Close file pointer\n     *\n     * @param  Resource  $fp   file pointer\n     * @param  string    $hash file hash\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    public function close($fp, $hash) {\n        $this->fcloseCE($fp, $this->decode($hash));\n    }\n\n    /**\n     * Create directory and return dir info\n     *\n     * @param  string   $dsthash  destination directory hash\n     * @param  string   $name directory name\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function mkdir($dsthash, $name) {\n        if ($this->commandDisabled('mkdir')) {\n            return $this->setError(ElFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!$this->nameAccepted($name)) {\n            return $this->setError(ElFinder::ERROR_INVALID_NAME);\n        }\n\n        if (($dir = $this->dir($dsthash)) == false) {\n            return $this->setError(ElFinder::ERROR_TRGDIR_NOT_FOUND, '#'.$dsthash);\n        }\n\n        $path = $this->decode($dsthash);\n\n        if (!$dir['write'] || !$this->allowCreate($path, $name, true)) {\n            return $this->setError(ElFinder::ERROR_PERM_DENIED);\n        }\n\n        $dst  = $this->joinPathCE($path, $name);\n        $stat = $this->stat($dst);\n        if (!empty($stat)) {\n            return $this->setError(ElFinder::ERROR_EXISTS, $name);\n        }\n        $this->clearcache();\n        return ($path = $this->convEncOut($this->_mkdir($this->convEncIn($path), $this->convEncIn($name)))) ? $this->stat($path) : false;\n    }\n\n    /**\n     * Create empty file and return its info\n     *\n     * @param  string   $dst  destination directory\n     * @param  string   $name file name\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function mkfile($dst, $name) {\n        if ($this->commandDisabled('mkfile')) {\n            return $this->setError(ElFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!$this->nameAccepted($name)) {\n            return $this->setError(ElFinder::ERROR_INVALID_NAME);\n        }\n\n        if (($dir = $this->dir($dst)) == false) {\n            return $this->setError(ElFinder::ERROR_TRGDIR_NOT_FOUND, '#'.$dst);\n        }\n\n        $path = $this->decode($dst);\n\n        if (!$dir['write'] || !$this->allowCreate($path, $name, false)) {\n            return $this->setError(ElFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($this->stat($this->joinPathCE($path, $name))) {\n            return $this->setError(ElFinder::ERROR_EXISTS, $name);\n        }\n\n        $this->clearcache();\n        return ($path = $this->convEncOut($this->_mkfile($this->convEncIn($path), $this->convEncIn($name)))) ? $this->stat($path) : false;\n    }\n\n    /**\n     * Rename file and return file info\n     *\n     * @param  string  $hash  file hash\n     * @param  string  $name  new file name\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function rename($hash, $name) {\n        if ($this->commandDisabled('rename')) {\n            return $this->setError(ElFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!$this->nameAccepted($name)) {\n            return $this->setError(ElFinder::ERROR_INVALID_NAME, $name);\n        }\n\n        $mimeByName = ElFinderVolumeDriver::mimetypeInternalDetect($name);\n        if ($mimeByName && $mimeByName !== 'unknown' && !$this->allowPutMime($mimeByName)) {\n            return $this->setError(ElFinder::ERROR_INVALID_NAME, $name);\n        }\n\n        if (!($file = $this->file($hash))) {\n            return $this->setError(ElFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if ($name == $file['name']) {\n            return $file;\n        }\n\n        if (!empty($file['locked'])) {\n            return $this->setError(ElFinder::ERROR_LOCKED, $file['name']);\n        }\n\n        $path = $this->decode($hash);\n        $dir  = $this->dirnameCE($path);\n        $stat = $this->stat($this->joinPathCE($dir, $name));\n        if ($stat) {\n            return $this->setError(ElFinder::ERROR_EXISTS, $name);\n        }\n\n        if (!$this->allowCreate($dir, $name, ($file['mime'] === 'directory'))) {\n            return $this->setError(ElFinder::ERROR_PERM_DENIED);\n        }\n\n        $this->rmTmb($file); // remove old name tmbs, we cannot do this after dir move\n\n\n        if ($path = $this->convEncOut($this->_move($this->convEncIn($path), $this->convEncIn($dir), $this->convEncIn($name)))) {\n            $this->clearcache();\n            return $this->stat($path);\n        }\n        return false;\n    }\n\n    /**\n     * Create file copy with suffix \"copy number\" and return its info\n     *\n     * @param  string   $hash    file hash\n     * @param  string   $suffix  suffix to add to file name\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function duplicate($hash, $suffix='copy') {\n        if ($this->commandDisabled('duplicate')) {\n            return $this->setError(ElFinder::ERROR_COPY, '#'.$hash, ElFinder::ERROR_PERM_DENIED);\n        }\n\n        if (($file = $this->file($hash)) == false) {\n            return $this->setError(ElFinder::ERROR_COPY, ElFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        $path = $this->decode($hash);\n        $dir  = $this->dirnameCE($path);\n        $name = $this->uniqueName($dir, $this->basenameCE($path), ' '.$suffix.' ');\n\n        if (!$this->allowCreate($dir, $name, ($file['mime'] === 'directory'))) {\n            return $this->setError(ElFinder::ERROR_PERM_DENIED);\n        }\n\n        return ($path = $this->copy($path, $dir, $name)) == false\n            ? false\n            : $this->stat($path);\n    }\n\n    /**\n     * Save uploaded file.\n     * On success return array with new file stat and with removed file hash (if existed file was replaced)\n     *\n     * @param  Resource $fp      file pointer\n     * @param  string   $dst     destination folder hash\n     * @param  string   $src     file name\n     * @param  string   $tmpname file tmp name - required to detect mime type\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function upload($fp, $dst, $name, $tmpname) {\n        if ($this->commandDisabled('upload')) {\n            return $this->setError(ElFinder::ERROR_PERM_DENIED);\n        }\n\n        if (($dir = $this->dir($dst)) == false) {\n            return $this->setError(ElFinder::ERROR_TRGDIR_NOT_FOUND, '#'.$dst);\n        }\n\n        if (!$dir['write']) {\n            return $this->setError(ElFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!$this->nameAccepted($name)) {\n            return $this->setError(ElFinder::ERROR_INVALID_NAME);\n        }\n\n        $mime = $this->mimetype($this->mimeDetect == 'internal' ? $name : $tmpname, $name);\n        $mimeByName = '';\n        if ($this->mimeDetect !== 'internal') {\n            $mimeByName = ElFinderVolumeDriver::mimetypeInternalDetect($name);\n            if ($mime == 'unknown') {\n                $mime = $mimeByName;\n            }\n        }\n\n        if (!$this->allowPutMime($mime) || ($mimeByName && $mimeByName !== 'unknown' && !$this->allowPutMime($mimeByName))) {\n            return $this->setError(ElFinder::ERROR_UPLOAD_FILE_MIME);\n        }\n\n        $tmpsize = sprintf('%u', filesize($tmpname));\n        if ($this->uploadMaxSize > 0 && $tmpsize > $this->uploadMaxSize) {\n            return $this->setError(ElFinder::ERROR_UPLOAD_FILE_SIZE);\n        }\n\n        $dstpath = $this->decode($dst);\n        $test    = $this->joinPathCE($dstpath, $name);\n\n        $file = $this->stat($test);\n        $this->clearcache();\n\n        if ($file) { // file exists\n            // check POST data `overwrite` for 3rd party uploader\n            $overwrite = isset($_POST['overwrite'])? (bool)$_POST['overwrite'] : $this->options['uploadOverwrite'];\n            if ($overwrite) {\n                if (!$file['write']) {\n                    return $this->setError(ElFinder::ERROR_PERM_DENIED);\n                } elseif ($file['mime'] == 'directory') {\n                    return $this->setError(ElFinder::ERROR_NOT_REPLACE, $name);\n                }\n                $this->remove($test);\n            } else {\n                $name = $this->uniqueName($dstpath, $name, '-', false);\n            }\n        }\n\n        $stat = array(\n            'mime'   => $mime,\n            'width'  => 0,\n            'height' => 0,\n            'size'   => $tmpsize);\n\n        // $w = $h = 0;\n        if (strpos($mime, 'image') === 0 && ($s = getimagesize($tmpname))) {\n            $stat['width'] = $s[0];\n            $stat['height'] = $s[1];\n        }\n        // $this->clearcache();\n        if (($path = $this->saveCE($fp, $dstpath, $name, $stat)) == false) {\n            return false;\n        }\n\n        return $this->stat($path);\n    }\n\n    /**\n     * Paste files\n     *\n     * @param  Object  $volume  source volume\n     * @param  string  $source  file hash\n     * @param  string  $dst     destination dir hash\n     * @param  bool    $rmSrc   remove source after copy?\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function paste($volume, $src, $dst, $rmSrc = false) {\n        $err = $rmSrc ? ElFinder::ERROR_MOVE : ElFinder::ERROR_COPY;\n\n        if ($this->commandDisabled('paste')) {\n            return $this->setError($err, '#'.$src, ElFinder::ERROR_PERM_DENIED);\n        }\n\n        if (($file = $volume->file($src, $rmSrc)) == false) {\n            return $this->setError($err, '#'.$src, ElFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        $name = $file['name'];\n        $errpath = $volume->path($file['hash']);\n\n        if (($dir = $this->dir($dst)) == false) {\n            return $this->setError($err, $errpath, ElFinder::ERROR_TRGDIR_NOT_FOUND, '#'.$dst);\n        }\n\n        if (!$dir['write'] || !$file['read']) {\n            return $this->setError($err, $errpath, ElFinder::ERROR_PERM_DENIED);\n        }\n\n        $destination = $this->decode($dst);\n\n        if (($test = $volume->closest($src, $rmSrc ? 'locked' : 'read', $rmSrc))) {\n            return $rmSrc\n                ? $this->setError($err, $errpath, ElFinder::ERROR_LOCKED, $volume->path($test))\n                : $this->setError($err, $errpath, !empty($file['thash'])? ElFinder::ERROR_PERM_DENIED : ElFinder::ERROR_MKOUTLINK);\n        }\n\n        $test = $this->joinPathCE($destination, $name);\n        $stat = $this->stat($test);\n        $this->clearcache();\n        if ($stat) {\n            if ($this->options['copyOverwrite']) {\n                // do not replace file with dir or dir with file\n                if (!$this->isSameType($file['mime'], $stat['mime'])) {\n                    return $this->setError(ElFinder::ERROR_NOT_REPLACE, $this->path($stat['hash']));\n                }\n                // existed file is not writable\n                if (!$stat['write']) {\n                    return $this->setError($err, $errpath, ElFinder::ERROR_PERM_DENIED);\n                }\n                // existed file locked or has locked child\n                if (($locked = $this->closestByAttr($test, 'locked', true))) {\n                    $stat = $this->stat($locked);\n                    return $this->setError(ElFinder::ERROR_LOCKED, $this->path($stat['hash']));\n                }\n                // target is entity file of alias\n                if ($volume == $this && ($test == @$file['target'] || $test == $this->decode($src))) {\n                    return $this->setError(ElFinder::ERROR_REPLACE, $errpath);\n                }\n                // remove existed file\n                if (!$this->remove($test)) {\n                    return $this->setError(ElFinder::ERROR_REPLACE, $this->path($stat['hash']));\n                }\n            } else {\n                $name = $this->uniqueName($destination, $name, ' ', false);\n            }\n        }\n\n        // copy/move inside current volume\n        if ($volume == $this) {\n            $source = $this->decode($src);\n            // do not copy into itself\n            if ($this->inpathCE($destination, $source)) {\n                return $this->setError(ElFinder::ERROR_COPY_INTO_ITSELF, $errpath);\n            }\n            $method = $rmSrc ? 'move' : 'copy';\n            return ($path = $this->$method($source, $destination, $name)) ? $this->stat($path) : false;\n        }\n\n        // copy/move from another volume\n        if (!$this->options['copyTo'] || !$volume->copyFromAllowed()) {\n            return $this->setError(ElFinder::ERROR_COPY, $errpath, ElFinder::ERROR_PERM_DENIED);\n        }\n\n        if (($path = $this->copyFrom($volume, $src, $destination, $name)) == false) {\n            return false;\n        }\n\n        if ($rmSrc) {\n            if (!$volume->rm($src)) {\n                return $this->setError(ElFinder::ERROR_MOVE, $errpath, ElFinder::ERROR_RM_SRC);\n            }\n        }\n        return $this->stat($path);\n    }\n\n    /**\n     * Return path to archive of target items\n     *\n     * @param  array  $hashes\n     * @return string archive path\n     * @author Naoki Sawada\n     */\n    public function zipdl($hashes) {\n        if ($this->commandDisabled('zipdl')) {\n            return $this->setError(ElFinder::ERROR_PERM_DENIED);\n        }\n\n        $archivers = $this->getArchivers();\n        $cmd = null;\n        if (!$archivers || empty($archivers['create'])) {\n            return false;\n        }\n        $archivers = $archivers['create'];\n        foreach(array('zip', 'tgz') as $ext) {\n            $mime = self::$mimetypes[$ext];\n            if (isset($archivers[$mime])) {\n                $cmd = $archivers[$mime];\n                break;\n            }\n        }\n        if (!$cmd) {\n            $cmd = $archivers[0];\n            $ext = $cmd['ext'];\n            $mime = ElFinderVolumeDriver::mimetypeInternalDetect('file.'.$ext);\n        }\n        $res = false;\n        $mixed = false;\n        $hashes = array_merge($hashes);\n        $dirname = dirname(str_replace($this->separator, DIRECTORY_SEPARATOR, $this->path($hashes[0])));\n        $cnt = count($hashes);\n        if ($cnt > 1) {\n            for($i = 1; $i < $cnt; $i++) {\n                if ($dirname !== dirname(str_replace($this->separator, DIRECTORY_SEPARATOR, $this->path($hashes[$i])))) {\n                    $mixed = true;\n                    break;\n                }\n            }\n        }\n        if ($mixed || $this->root == $this->dirnameCE($this->decode($hashes[0]))) {\n            $prefix = $this->rootName;\n        } else {\n            $prefix = basename($dirname);\n        }\n        if ($dir = $this->getItemsInHand($hashes)) {\n            $tmppre = (substr(PHP_OS, 0, 3) === 'WIN')? 'zdl' : 'elfzdl';\n            $pdir = dirname($dir);\n            // garbage collection\n            $ttl = 7200; // expire 2h\n            $time = time();\n            foreach(glob($pdir.DIRECTORY_SEPARATOR.$tmppre.'*') as $_file) {\n                if (filemtime($_file) + $ttl < $time) {\n                    @unlink($_file);\n                }\n            }\n            $files = array_diff(scandir($dir), array('.', '..'));\n            if ($files && ($arc = tempnam($dir, $tmppre))) {\n                unlink($arc);\n                $arc = $arc.'.'.$ext;\n                $name = basename($arc);\n                if ($arc = $this->makeArchive($dir, $files, $name, $cmd)) {\n                    $file = tempnam($pdir, $tmppre);\n                    unlink($file);\n                    $res = @rename($arc, $file);\n                    $this->rmdirRecursive($dir);\n                }\n            }\n        }\n        return $res ? array('path' => $file, 'ext' => $ext, 'mime' => $mime, 'prefix' => $prefix) : false;\n    }\n\n    /**\n     * Return file contents\n     *\n     * @param  string  $hash  file hash\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function getContents($hash) {\n        $file = $this->file($hash);\n\n        if (!$file) {\n            return $this->setError(ElFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if ($file['mime'] == 'directory') {\n            return $this->setError(ElFinder::ERROR_NOT_FILE);\n        }\n\n        if (!$file['read']) {\n            return $this->setError(ElFinder::ERROR_PERM_DENIED);\n        }\n\n        return $this->convEncOut($this->_getContents($this->convEncIn($this->decode($hash))));\n    }\n\n    /**\n     * Put content in text file and return file info.\n     *\n     * @param  string  $hash     file hash\n     * @param  string  $content  new file content\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function putContents($hash, $content) {\n        if ($this->commandDisabled('edit')) {\n            return $this->setError(ElFinder::ERROR_PERM_DENIED);\n        }\n\n        $path = $this->decode($hash);\n\n        if (!($file = $this->file($hash))) {\n            return $this->setError(ElFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if (!$file['write']) {\n            return $this->setError(ElFinder::ERROR_PERM_DENIED);\n        }\n\n        // check MIME\n        $name = $this->basenameCE($path);\n        $mime = '';\n        $mimeByName = ElFinderVolumeDriver::mimetypeInternalDetect($name);\n        if ($this->mimeDetect !== 'internal') {\n            if ($tp = tmpfile()) {\n                fwrite($tp, $content);\n                $info = stream_get_meta_data($tp);\n                $filepath = $info['uri'];\n                $mime = $this->mimetype($filepath, $name);\n                fclose($tp);\n            }\n        }\n        if (!$this->allowPutMime($mimeByName) || ($mime && $mime !== 'unknown' && !$this->allowPutMime($mime))) {\n            return $this->setError(ElFinder::ERROR_UPLOAD_FILE_MIME);\n        }\n\n        $this->clearcache();\n        return $this->convEncOut($this->_filePutContents($this->convEncIn($path), $content)) ? $this->stat($path) : false;\n    }\n\n    /**\n     * Extract files from archive\n     *\n     * @param  string  $hash  archive hash\n     * @return array|bool\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     **/\n    public function extract($hash, $makedir = null) {\n        if ($this->commandDisabled('extract')) {\n            return $this->setError(ElFinder::ERROR_PERM_DENIED);\n        }\n\n        if (($file = $this->file($hash)) == false) {\n            return $this->setError(ElFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        $archiver = isset($this->archivers['extract'][$file['mime']])\n            ? $this->archivers['extract'][$file['mime']]\n            : false;\n\n        if (!$archiver) {\n            return $this->setError(ElFinder::ERROR_NOT_ARCHIVE);\n        }\n\n        $path   = $this->decode($hash);\n        $parent = $this->stat($this->dirnameCE($path));\n\n        if (!$file['read'] || !$parent['write']) {\n            return $this->setError(ElFinder::ERROR_PERM_DENIED);\n        }\n        $this->clearcache();\n        $this->extractToNewdir = is_null($makedir)? 'auto' : (bool)$makedir;\n\n        if ($path = $this->convEncOut($this->_extract($this->convEncIn($path), $archiver))) {\n            if (is_array($path)) {\n                foreach ($path as $_k => $_p) {\n                    $path[$_k] = $this->stat($_p);\n                }\n            } else {\n                $path = $this->stat($path);\n            }\n            return $path;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Add files to archive\n     *\n     **/\n    public function archive($hashes, $mime, $name = '') {\n        if ($this->commandDisabled('archive')) {\n            return $this->setError(ElFinder::ERROR_PERM_DENIED);\n        }\n\n        $archiver = isset($this->archivers['create'][$mime])\n            ? $this->archivers['create'][$mime]\n            : false;\n\n        if (!$archiver) {\n            return $this->setError(ElFinder::ERROR_ARCHIVE_TYPE);\n        }\n\n        $files = array();\n\n        foreach ($hashes as $hash) {\n            if (($file = $this->file($hash)) == false) {\n                return $this->error(ElFinder::ERROR_FILE_NOT_FOUND, '#'.$hash);\n            }\n            if (!$file['read']) {\n                return $this->error(ElFinder::ERROR_PERM_DENIED);\n            }\n            $path = $this->decode($hash);\n            if (!isset($dir)) {\n                $dir = $this->dirnameCE($path);\n                $stat = $this->stat($dir);\n                if (!$stat['write']) {\n                    return $this->error(ElFinder::ERROR_PERM_DENIED);\n                }\n            }\n\n            $files[] = $this->basenameCE($path);\n        }\n\n        if ($name === '') {\n            $name = count($files) == 1 ? $files[0] : 'Archive';\n        } else {\n            $name = str_replace(array('/', '\\\\'), '_', preg_replace('/\\.' . preg_quote($archiver['ext'], '/') . '$/i', '', $name));\n        }\n        $name .='.' . $archiver['ext'];\n        $name = $this->uniqueName($dir, $name, '');\n        $this->clearcache();\n        return ($path = $this->convEncOut($this->_archive($this->convEncIn($dir), $this->convEncIn($files), $this->convEncIn($name), $archiver))) ? $this->stat($path) : false;\n    }\n\n    /**\n     * Resize image\n     *\n     * @param  string   $hash    image file\n     * @param  int      $width   new width\n     * @param  int      $height  new height\n     * @param  int      $x       X start poistion for crop\n     * @param  int      $y       Y start poistion for crop\n     * @param  string   $mode    action how to mainpulate image\n     * @param  string   $bg      background color\n     * @param  int      $degree  rotete degree\n     * @param  int      $jpgQuality  JEPG quality (1-100)\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     * @author nao-pon\n     * @author Troex Nevelin\n     **/\n    public function resize($hash, $width, $height, $x, $y, $mode = 'resize', $bg = '', $degree = 0, $jpgQuality = null) {\n        if ($this->commandDisabled('resize')) {\n            return $this->setError(ElFinder::ERROR_PERM_DENIED);\n        }\n\n        if (($file = $this->file($hash)) == false) {\n            return $this->setError(ElFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if (!$file['write'] || !$file['read']) {\n            return $this->setError(ElFinder::ERROR_PERM_DENIED);\n        }\n\n        $path = $this->decode($hash);\n\n        $work_path = $this->getWorkFile($this->encoding? $this->convEncIn($path, true) : $path);\n\n        if (!$work_path || !is_writable($work_path)) {\n            if ($work_path && $path !== $work_path && is_file($work_path)) {\n                @unlink($work_path);\n            }\n            return $this->setError(ElFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($this->imgLib != 'imagick') {\n            if (ElFinder::isAnimationGif($work_path)) {\n                return $this->setError(ElFinder::ERROR_UNSUPPORT_TYPE);\n            }\n        }\n\n        switch($mode) {\n\n            case 'propresize':\n                $result = $this->imgResize($work_path, $width, $height, true, true, null, $jpgQuality);\n                break;\n\n            case 'crop':\n                $result = $this->imgCrop($work_path, $width, $height, $x, $y, null, $jpgQuality);\n                break;\n\n            case 'fitsquare':\n                $result = $this->imgSquareFit($work_path, $width, $height, 'center', 'middle', ($bg ? $bg : $this->options['tmbBgColor']), null, $jpgQuality);\n                break;\n\n            case 'rotate':\n                $result = $this->imgRotate($work_path, $degree, ($bg ? $bg : $this->options['tmbBgColor']), null, $jpgQuality);\n                break;\n\n            default:\n                $result = $this->imgResize($work_path, $width, $height, false, true, null, $jpgQuality);\n                break;\n        }\n\n        $ret = false;\n        if ($result) {\n            $stat = $this->stat($path);\n            clearstatcache();\n            $fstat = stat($work_path);\n            $stat['size'] = $fstat['size'];\n            $stat['ts'] = $fstat['mtime'];\n            if ($imgsize = @getimagesize($work_path)) {\n                $stat['width'] = $imgsize[0];\n                $stat['height'] = $imgsize[1];\n                $stat['mime'] = $imgsize['mime'];\n            }\n            if ($path !== $work_path) {\n                if ($fp = @fopen($work_path, 'rb')) {\n                    $ret = $this->saveCE($fp, $this->dirnameCE($path), $this->basenameCE($path), $stat);\n                    @fclose($fp);\n                }\n            } else {\n                $ret = true;\n            }\n            if ($ret) {\n                $this->rmTmb($file);\n                $this->clearcache();\n                $ret = $this->stat($path);\n                $ret['width'] = $stat['width'];\n                $ret['height'] = $stat['height'];\n            }\n        }\n        if ($path !== $work_path) {\n            is_file($work_path) && @unlink($work_path);\n        }\n\n        return $ret;\n    }\n\n    /**\n     * Remove file/dir\n     *\n     * @param  string  $hash  file hash\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    public function rm($hash) {\n        return $this->commandDisabled('rm')\n            ? $this->setError(ElFinder::ERROR_PERM_DENIED)\n            : $this->remove($this->decode($hash));\n    }\n\n    /**\n     * Search files\n     *\n     * @param  string  $q  search string\n     * @param  array   $mimes\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function search($q, $mimes, $hash = null) {\n        $dir = null;\n        if ($hash) {\n            $dir = $this->decode($hash);\n            $stat = $this->stat($dir);\n            if (!$stat || $stat['mime'] !== 'directory' || !$stat['read']) {\n                $q = '';\n            }\n        }\n        if ($mimes && $this->onlyMimes) {\n            $mimes = array_intersect($mimes, $this->onlyMimes);\n            if (!$mimes) {\n                $q = '';\n            }\n        }\n        $this->searchStart = time();\n        return ($q === '' || $this->commandDisabled('search'))\n            ? array()\n            : $this->doSearch(is_null($dir)? $this->root : $dir, $q, $mimes);\n    }\n\n    /**\n     * Return image dimensions\n     *\n     * @param  string  $hash  file hash\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function dimensions($hash) {\n        if (($file = $this->file($hash)) == false) {\n            return false;\n        }\n\n        return $this->convEncOut($this->_dimensions($this->convEncIn($this->decode($hash)), $file['mime']));\n    }\n\n    /**\n     * Return content URL (for netmout volume driver)\n     * If file.url == 1 requests from JavaScript client with XHR\n     *\n     * @param string $hash  file hash\n     * @param array $options  options array\n     * @return boolean|string\n     * @author Naoki Sawada\n     */\n    public function getContentUrl($hash, $options = array()) {\n        if (($file = $this->file($hash)) == false || !$file['url'] || $file['url'] == 1) {\n            return false;\n        }\n        return $file['url'];\n    }\n\n    /**\n     * Return temp path\n     *\n     * @return string\n     * @author Naoki Sawada\n     */\n    public function getTempPath() {\n        $tempPath = null;\n        if (isset($this->tmpPath) && $this->tmpPath && is_writable($this->tmpPath)) {\n            $tempPath = $this->tmpPath;\n        } else if (isset($this->tmp) && $this->tmp && is_writable($this->tmp)) {\n            $tempPath = $this->tmp;\n        } else if (function_exists('sys_get_temp_dir')) {\n            $tempPath = sys_get_temp_dir();\n        } else if (isset($this->tmbPath) && $this->tmbPath && is_writable($this->tmbPath)) {\n            $tempPath = $this->tmbPath;\n        }\n        if ($tempPath && DIRECTORY_SEPARATOR !== '/') {\n            $tempPath = str_replace('/', DIRECTORY_SEPARATOR, $tempPath);\n        }\n        return $tempPath;\n    }\n\n    /**\n     * (Make &) Get upload taget dirctory hash\n     *\n     * @param string $baseTargetHash\n     * @param string $path\n     * @param array  $result\n     * @return boolean|string\n     * @author Naoki Sawada\n     */\n    public function getUploadTaget($baseTargetHash, $path, & $result) {\n        $base = $this->decode($baseTargetHash);\n        $targetHash = $baseTargetHash;\n        $path = ltrim($path, $this->separator);\n        $dirs = explode($this->separator, $path);\n        array_pop($dirs);\n        foreach($dirs as $dir) {\n            $targetPath = $this->joinPathCE($base, $dir);\n            if (! $_realpath = $this->realpath($this->encode($targetPath))) {\n                if ($stat = $this->mkdir($targetHash, $dir)) {\n                    $result['added'][] = $stat;\n                    $targetHash = $stat['hash'];\n                    $base = $this->decode($targetHash);\n                } else {\n                    return false;\n                }\n            } else {\n                $targetHash = $this->encode($_realpath);\n                if ($this->dir($targetHash)) {\n                    $base = $this->decode($targetHash);\n                } else {\n                    return false;\n                }\n            }\n        }\n        return $targetHash;\n    }\n\n    /**\n     * Return this uploadMaxSize value\n     *\n     * @return integer\n     * @author Naoki Sawada\n     */\n    public function getUploadMaxSize() {\n        return $this->uploadMaxSize;\n    }\n\n    /**\n     * Save error message\n     *\n     * @param  array  error\n     * @return false\n     * @author Dmitry(dio) Levashov\n     **/\n    protected function setError($error) {\n\n        $this->error = array();\n\n        foreach (func_get_args() as $err) {\n            if (is_array($err)) {\n                $this->error = array_merge($this->error, $err);\n            } else {\n                $this->error[] = $err;\n            }\n        }\n\n        // $this->error = is_array($error) ? $error : func_get_args();\n        return false;\n    }\n\n    /*********************************************************************/\n    /*                               FS API                              */\n    /*********************************************************************/\n\n    /***************** server encoding support *******************/\n\n    /**\n     * Return parent directory path (with convert encording)\n     *\n     * @param  string  $path  file path\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function dirnameCE($path) {\n        return (!$this->encoding)? $this->_dirname($path) :\t$this->convEncOut($this->_dirname($this->convEncIn($path)));\n    }\n\n    /**\n     * Return file name (with convert encording)\n     *\n     * @param  string  $path  file path\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function basenameCE($path) {\n        return (!$this->encoding)? $this->_basename($path) : $this->convEncOut($this->_basename($this->convEncIn($path)));\n    }\n\n    /**\n     * Join dir name and file name and return full path. (with convert encording)\n     * Some drivers (db) use int as path - so we give to concat path to driver itself\n     *\n     * @param  string  $dir   dir path\n     * @param  string  $name  file name\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function joinPathCE($dir, $name) {\n        return (!$this->encoding)? $this->_joinPath($dir, $name) : $this->convEncOut($this->_joinPath($this->convEncIn($dir), $this->convEncIn($name)));\n    }\n\n    /**\n     * Return normalized path (with convert encording)\n     *\n     * @param  string  $path  file path\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function normpathCE($path) {\n        return (!$this->encoding)? $this->_normpath($path) : $this->convEncOut($this->_normpath($this->convEncIn($path)));\n    }\n\n    /**\n     * Return file path related to root dir (with convert encording)\n     *\n     * @param  string  $path  file path\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function relpathCE($path) {\n        return (!$this->encoding)? $this->_relpath($path) : $this->convEncOut($this->_relpath($this->convEncIn($path)));\n    }\n\n    /**\n     * Convert path related to root dir into real path (with convert encording)\n     *\n     * @param  string  $path  rel file path\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function abspathCE($path) {\n        return (!$this->encoding)? $this->_abspath($path): $this->convEncOut($this->_abspath($this->convEncIn($path)));\n    }\n\n    /**\n     * Return true if $path is children of $parent (with convert encording)\n     *\n     * @param  string  $path    path to check\n     * @param  string  $parent  parent path\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    protected function inpathCE($path, $parent) {\n        return (!$this->encoding)? $this->_inpath($path, $parent) : $this->convEncOut($this->_inpath($this->convEncIn($path), $this->convEncIn($parent)));\n    }\n\n    /**\n     * Open file and return file pointer (with convert encording)\n     *\n     * @param  string  $path  file path\n     * @param  bool    $write open file for writing\n     * @return resource|false\n     * @author Naoki Sawada\n     **/\n    protected function fopenCE($path, $mode='rb') {\n        return (!$this->encoding)? $this->_fopen($path, $mode) : $this->convEncOut($this->_fopen($this->convEncIn($path), $mode));\n    }\n\n    /**\n     * Close opened file (with convert encording)\n     *\n     * @param  resource  $fp    file pointer\n     * @param  string    $path  file path\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    protected function fcloseCE($fp, $path='') {\n        return (!$this->encoding)? $this->_fclose($fp, $path) : $this->convEncOut($this->_fclose($fp, $this->convEncIn($path)));\n    }\n\n    /**\n     * Create new file and write into it from file pointer. (with convert encording)\n     * Return new file path or false on error.\n     *\n     * @param  resource  $fp   file pointer\n     * @param  string    $dir  target dir path\n     * @param  string    $name file name\n     * @param  array     $stat file stat (required by some virtual fs)\n     * @return bool|string\n     * @author Naoki Sawada\n     **/\n    protected function saveCE($fp, $dir, $name, $stat) {\n        return (!$this->encoding)? $this->_save($fp, $dir, $name, $stat) : $this->convEncOut($this->_save($fp, $this->convEncIn($dir), $this->convEncIn($name), $this->convEncIn($stat)));\n    }\n\n    /**\n     * Return true if path is dir and has at least one childs directory (with convert encording)\n     *\n     * @param  string  $path  dir path\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    protected function subdirsCE($path) {\n        if (!isset($this->subdirsCache[$path])) {\n            $this->subdirsCache[$path] = (!$this->encoding)? $this->_subdirs($path) : $this->convEncOut($this->_subdirs($this->convEncIn($path)));\n        }\n        return $this->subdirsCache[$path];\n    }\n\n    /**\n     * Return files list in directory (with convert encording)\n     *\n     * @param  string  $path  dir path\n     * @return array\n     * @author Naoki Sawada\n     **/\n    protected function scandirCE($path) {\n        return (!$this->encoding)? $this->_scandir($path) : $this->convEncOut($this->_scandir($this->convEncIn($path)));\n    }\n\n    /**\n     * Create symlink (with convert encording)\n     *\n     * @param  string  $source     file to link to\n     * @param  string  $targetDir  folder to create link in\n     * @param  string  $name       symlink name\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    protected function symlinkCE($source, $targetDir, $name) {\n        return (!$this->encoding)? $this->_symlink($source, $targetDir, $name) : $this->convEncOut($this->_symlink($this->convEncIn($source), $this->convEncIn($targetDir), $this->convEncIn($name)));\n    }\n\n    /***************** paths *******************/\n\n    /**\n     * Encode path into hash\n     *\n     * @param  string  file path\n     * @return string\n     * @author Dmitry (dio) Levashov\n     * @author Troex Nevelin\n     **/\n    public function encode($path) {\n        if ($path !== '') {\n\n            // cut ROOT from $path for security reason, even if hacker decodes the path he will not know the root\n            $p = $this->relpathCE($path);\n            // if reqesting root dir $path will be empty, then assign '/' as we cannot leave it blank for crypt\n            if ($p === '')\t{\n                $p = DIRECTORY_SEPARATOR;\n            }\n\n            // TODO crypt path and return hash\n            $hash = $this->crypt($p);\n            // hash is used as id in HTML that means it must contain vaild chars\n            // make base64 html safe and append prefix in begining\n            $hash = strtr(base64_encode($hash), '+/=', '-_.');\n            // remove dots '.' at the end, before it was '=' in base64\n            $hash = rtrim($hash, '.');\n            // append volume id to make hash unique\n            return $this->id.$hash;\n        }\n    }\n\n    /**\n     * Decode path from hash\n     *\n     * @param  string  file hash\n     * @return string\n     * @author Dmitry (dio) Levashov\n     * @author Troex Nevelin\n     **/\n    public function decode($hash) {\n        if (strpos($hash, $this->id) === 0) {\n            // cut volume id after it was prepended in encode\n            $h = substr($hash, strlen($this->id));\n            // replace HTML safe base64 to normal\n            $h = base64_decode(strtr($h, '-_.', '+/='));\n            // TODO uncrypt hash and return path\n            $path = $this->uncrypt($h);\n            // append ROOT to path after it was cut in encode\n            return $this->abspathCE($path);//$this->root.($path == DIRECTORY_SEPARATOR ? '' : DIRECTORY_SEPARATOR.$path);\n        }\n    }\n\n    /**\n     * Return crypted path\n     * Not implemented\n     *\n     * @param  string  path\n     * @return mixed\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function crypt($path) {\n        return $path;\n    }\n\n    /**\n     * Return uncrypted path\n     * Not implemented\n     *\n     * @param  mixed  hash\n     * @return mixed\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function uncrypt($hash) {\n        return $hash;\n    }\n\n    /**\n     * Validate file name based on $this->options['acceptedName'] regexp or function\n     *\n     * @param  string  $name  file name\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function nameAccepted($name) {\n        if (!json_encode($name)) {\n            return false;\n        }\n        if ($this->nameValidator) {\n            if (is_callable($this->nameValidator)) {\n                $res = call_user_func($this->nameValidator, $name);\n                return $res;\n            }\n            if (preg_match($this->nameValidator, '') !== false) {\n                return preg_match($this->nameValidator, $name);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return new unique name based on file name and suffix\n     *\n     * @param  string  $path    file path\n     * @param  string  $suffix  suffix append to name\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function uniqueName($dir, $name, $suffix = ' copy', $checkNum = true, $start = 1) {\n        $ext  = '';\n\n        if (preg_match('/\\.((tar\\.(gz|bz|bz2|z|lzo))|cpio\\.gz|ps\\.gz|xcf\\.(gz|bz2)|[a-z0-9]{1,4})$/i', $name, $m)) {\n            $ext  = '.'.$m[1];\n            $name = substr($name, 0,  strlen($name)-strlen($m[0]));\n        }\n\n        if ($checkNum && preg_match('/('.preg_quote($suffix, '/').')(\\d*)$/i', $name, $m)) {\n            $i    = (int)$m[2];\n            $name = substr($name, 0, strlen($name)-strlen($m[2]));\n        } else {\n            $i     = $start;\n            $name .= $suffix;\n        }\n        $max = $i+100000;\n\n        while ($i <= $max) {\n            $n = $name.($i > 0 ? $i : '').$ext;\n\n            if (!$this->stat($this->joinPathCE($dir, $n))) {\n                $this->clearcache();\n                return $n;\n            }\n            $i++;\n        }\n        return $name.md5($dir).$ext;\n    }\n\n    /**\n     * Converts character encoding from UTF-8 to server's one\n     *\n     * @param  mixed  $var           target string or array var\n     * @param  bool   $restoreLocale do retore global locale, default is false\n     * @param  string $unknown       replaces character for unknown\n     * @return mixed\n     * @author Naoki Sawada\n     */\n    public function convEncIn($var = null, $restoreLocale = false, $unknown = '_') {\n        return (!$this->encoding)? $var : $this->convEnc($var, 'UTF-8', $this->encoding, $this->options['locale'], $restoreLocale, $unknown);\n    }\n\n    /**\n     * Converts character encoding from server's one to UTF-8\n     *\n     * @param  mixed  $var           target string or array var\n     * @param  bool   $restoreLocale do retore global locale, default is true\n     * @param  string $unknown       replaces character for unknown\n     * @return mixed\n     * @author Naoki Sawada\n     */\n    public function convEncOut($var = null, $restoreLocale = true, $unknown = '_') {\n        return (!$this->encoding)? $var : $this->convEnc($var, $this->encoding, 'UTF-8', $this->options['locale'], $restoreLocale, $unknown);\n    }\n\n    /**\n     * Converts character encoding (base function)\n     *\n     * @param  mixed  $var     target string or array var\n     * @param  string $from    from character encoding\n     * @param  string $to      to character encoding\n     * @param  string $locale  local locale\n     * @param  string $unknown replaces character for unknown\n     * @return mixed\n     */\n    protected function convEnc($var, $from, $to, $locale, $restoreLocale, $unknown = '_') {\n        if (strtoupper($from) !== strtoupper($to)) {\n            if ($locale) {\n                @setlocale(LC_ALL, $locale);\n            }\n            if (is_array($var)) {\n                $_ret = array();\n                foreach($var as $_k => $_v) {\n                    $_ret[$_k] = $this->convEnc($_v, $from, $to, '', false, $unknown = '_');\n                }\n                $var = $_ret;\n            } else {\n                $_var = false;\n                if (is_string($var)) {\n                    $_var = $var;\n                    if (false !== ($_var = @iconv($from, $to.'//TRANSLIT', $_var))) {\n                        $_var = str_replace('?', $unknown, $_var);\n                    }\n                }\n                if  ($_var !== false) {\n                    $var = $_var;\n                }\n            }\n            if ($restoreLocale) {\n                setlocale(LC_ALL, ElFinder::$locale);\n            }\n        }\n        return $var;\n    }\n\n    /*********************** util mainly for inheritance class *********************/\n\n    /**\n     * Get temporary filename. Tempfile will be removed when after script execution finishes or exit() is called.\n     * When needing the unique file to a path, give $path to parameter.\n     *\n     * @param  string       $path for get unique file to a path\n     * @return string|false\n     * @author Naoki Sawada\n     */\n    protected function getTempFile($path = '') {\n        static $cache = array();\n        static $rmfunc;\n\n        $key = '';\n        if ($path !== '') {\n            $key = $this->id . '#' . $path;\n            if (isset($cache[$key])) {\n                return $cache[$key];\n            }\n        }\n\n        if ($tmpdir = $this->getTempPath()) {\n            if (!$rmfunc) {\n                $rmfunc = create_function('$f', 'is_file($f) && @unlink($f);');\n            }\n            $name = tempnam($tmpdir, 'ELF');\n            if ($key) {\n                $cache[$key] = $name;\n            }\n            register_shutdown_function($rmfunc, $name);\n            return $name;\n        }\n\n        return false;\n    }\n\n    /**\n     * File path of local server side work file path\n     *\n     * @param  string $path path need convert encoding to server encoding\n     * @return string\n     * @author Naoki Sawada\n     */\n    protected function getWorkFile($path) {\n        if ($work = $this->getTempFile()) {\n            if ($wfp = fopen($work, 'wb')) {\n                if ($fp = $this->_fopen($path)) {\n                    while(!feof($fp)) {\n                        fwrite($wfp, fread($fp, 8192));\n                    }\n                    $this->_fclose($fp, $path);\n                    fclose($wfp);\n                    return $work;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Get image size array with `dimensions`\n     *\n     * @param string $path path need convert encoding to server encoding\n     * @param string $mime file mime type\n     * @return array|false\n     */\n    public function getImageSize($path, $mime = '') {\n        $size = false;\n        if ($mime === '' || strtolower(substr($mime, 0, 5)) === 'image') {\n            if ($work = $this->getWorkFile($path)) {\n                if ($size = @getimagesize($work)) {\n                    $size['dimensions'] = $size[0].'x'.$size[1];\n                }\n            }\n            is_file($work) && @unlink($work);\n        }\n        return $size;\n    }\n\n    /**\n     * Delete dirctory trees\n     *\n     * @param string $localpath path need convert encoding to server encoding\n     * @return boolean\n     * @author Naoki Sawada\n     */\n    protected function delTree($localpath) {\n        foreach ($this->_scandir($localpath) as $p) {\n            @set_time_limit(30);\n            $stat = $this->stat($this->convEncOut($p));\n            $this->convEncIn();\n            ($stat['mime'] === 'directory')? $this->delTree($p) : $this->_unlink($p);\n        }\n        return $this->_rmdir($localpath);\n    }\n\n    /**\n     * Copy items to a new temporary directory on the local server\n     *\n     * @param  array  $hashes  target hashes\n     * @param  string $dir     destination directory (for recurcive)\n     * @return string|false    saved path name\n     * @author Naoki Sawada\n     */\n    protected function getItemsInHand($hashes, $dir = null) {\n        static $totalSize = 0;\n        if (is_null($dir)) {\n            $totalSize = 0;\n            if (! $tmpDir = $this->getTempPath()) {\n                return false;\n            }\n            $dir = tempnam($tmpDir, 'elf');\n            if (!unlink($dir) || !mkdir($dir, 0700, true)) {\n                return false;\n            }\n            register_shutdown_function(array($this, 'rmdirRecursive'), $dir);\n        }\n        $res = true;\n        $files = array();\n        foreach ($hashes as $hash) {\n            if (($file = $this->file($hash)) == false) {\n                continue;\n            }\n            if (!$file['read']) {\n                continue;\n            }\n\n            $name = $file['name'];\n            // for call from search results\n            if (isset($files[$name])) {\n                $name = preg_replace('/^(.*?)(\\..*)?$/', '$1_'.$files[$name]++.'$2', $name);\n            } else {\n                $files[$name] = 1;\n            }\n            $target = $dir.DIRECTORY_SEPARATOR.$name;\n\n            if ($file['mime'] === 'directory') {\n                $chashes = array();\n                $_files = $this->scandir($hash);\n                foreach($_files as $_file) {\n                    if ($file['read']) {\n                        $chashes[] = $_file['hash'];\n                    }\n                }\n                if ($chashes) {\n                    mkdir($target, 0700, true);\n                    $res = $this->getItemsInHand($chashes, $target);\n                }\n                if (!$res) {\n                    break;\n                }\n                !empty($file['ts']) && @touch($target, $file['ts']);\n            } else {\n                $path = $this->decode($hash);\n                if ($fp = $this->fopenCE($path)) {\n                    if ($tfp = fopen($target, 'wb')) {\n                        $totalSize += stream_copy_to_stream($fp, $tfp);\n                        fclose($tfp);\n                    }\n                    !empty($file['ts']) && @touch($target, $file['ts']);\n                    $this->fcloseCE($fp, $path);\n                }\n                if ($this->options['maxArcFilesSize'] > 0 && $this->options['maxArcFilesSize'] < $totalSize) {\n                    $res = $this->setError(ElFinder::ERROR_ARC_MAXSIZE);\n                }\n            }\n        }\n        return $res? $dir : false;\n    }\n\n    /*********************** file stat *********************/\n\n    /**\n     * Check file attribute\n     *\n     * @param  string  $path  file path\n     * @param  string  $name  attribute name (read|write|locked|hidden)\n     * @param  bool    $val   attribute value returned by file system\n     * @param  bool    $isDir path is directory (true: directory, false: file)\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function attr($path, $name, $val=null, $isDir=null) {\n        if (!isset($this->defaults[$name])) {\n            return false;\n        }\n\n\n        $perm = null;\n\n        if ($this->access) {\n            $perm = call_user_func($this->access, $name, $path, $this->options['accessControlData'], $this, $isDir);\n\n            if ($perm !== null) {\n                return !!$perm;\n            }\n        }\n\n        if ($this->separator != '/') {\n            $path = str_replace($this->separator, '/', $this->relpathCE($path));\n        } else {\n            $path = $this->relpathCE($path);\n        }\n\n        $path = '/'.$path;\n\n        for ($i = 0, $c = count($this->attributes); $i < $c; $i++) {\n            $attrs = $this->attributes[$i];\n\n            if (isset($attrs[$name]) && isset($attrs['pattern']) && preg_match($attrs['pattern'], $path)) {\n                $perm = $attrs[$name];\n            }\n        }\n\n        return $perm === null ? (is_null($val)? $this->defaults[$name] : $val) : !!$perm;\n    }\n\n    /**\n     * Return true if file with given name can be created in given folder.\n     *\n     * @param string $dir  parent dir path\n     * @param string $name new file name\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function allowCreate($dir, $name, $isDir = null) {\n        $path = $this->joinPathCE($dir, $name);\n        $perm = null;\n\n        if ($this->access) {\n            $perm = call_user_func($this->access, 'write', $path, $this->options['accessControlData'], $this, $isDir);\n            if ($perm !== null) {\n                return !!$perm;\n            }\n        }\n\n        $testPath = $this->separator.$this->relpathCE($path);\n\n        for ($i = 0, $c = count($this->attributes); $i < $c; $i++) {\n            $attrs = $this->attributes[$i];\n\n            if (isset($attrs['write']) && isset($attrs['pattern']) && preg_match($attrs['pattern'], $testPath)) {\n                $perm = $attrs['write'];\n            }\n        }\n\n        return $perm === null ? true : $perm;\n    }\n\n    /**\n     * Return true if file MIME type can save with check uploadOrder config.\n     *\n     * @param string $mime\n     * @return boolean\n     */\n    protected function allowPutMime($mime) {\n        // logic based on http://httpd.apache.org/docs/2.2/mod/mod_authz_host.html#order\n        $allow  = $this->mimeAccepted($mime, $this->uploadAllow, null);\n        $deny   = $this->mimeAccepted($mime, $this->uploadDeny,  null);\n        $res = true; // default to allow\n        if (strtolower($this->uploadOrder[0]) == 'allow') { // array('allow', 'deny'), default is to 'deny'\n            $res = false; // default is deny\n            if (!$deny && ($allow === true)) { // match only allow\n                $res = true;\n            }// else (both match | no match | match only deny) { deny }\n        } else { // array('deny', 'allow'), default is to 'allow' - this is the default rule\n            $res = true; // default is allow\n            if (($deny === true) && !$allow) { // match only deny\n                $res = false;\n            } // else (both match | no match | match only allow) { allow }\n        }\n        return $res;\n    }\n\n    /**\n     * Return fileinfo\n     *\n     * @param  string  $path  file cache\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function stat($path) {\n        if ($path === false || is_null($path)) {\n            return false;\n        }\n        $is_root = ($path == $this->root);\n        if ($is_root) {\n            $rootKey = md5($path);\n            if (!isset($this->sessionCache['rootstat'])) {\n                $this->sessionCache['rootstat'] = array();\n            }\n            if (! $this->isMyReload()) {\n                // need $path as key for netmount/netunmount\n                if (isset($this->sessionCache['rootstat'][$rootKey])) {\n                    if ($ret = ElFinder::sessionDataDecode($this->sessionCache['rootstat'][$rootKey], 'array')) {\n                        return $ret;\n                    }\n                }\n            }\n        }\n        $ret = isset($this->cache[$path])\n            ? $this->cache[$path]\n            : $this->updateCache($path, $this->convEncOut($this->_stat($this->convEncIn($path))));\n        if ($is_root) {\n            $this->sessionRestart();\n            $this->sessionCache['rootstat'][$rootKey] = ElFinder::sessionDataEncode($ret);\n            ElFinder::sessionWrite();\n        }\n        return $ret;\n    }\n\n    /**\n     * Get root stat extra key values\n     *\n     * @return array stat extras\n     * @author Naoki Sawada\n     */\n    protected function getRootStatExtra() {\n        $stat = array();\n        if ($this->rootName) {\n            $stat['name'] = $this->rootName;\n        }\n        if (! empty($this->options['icon'])) {\n            $stat['icon'] = $this->options['icon'];\n        }\n        if (! empty($this->options['rootCssClass'])) {\n            $stat['csscls'] = $this->options['rootCssClass'];\n        }\n        if (! empty($this->tmbURL)) {\n            $stat['tmbUrl'] = $this->tmbURL;\n        }\n        $stat['uiCmdMap'] = (isset($this->options['uiCmdMap']) && is_array($this->options['uiCmdMap']))? $this->options['uiCmdMap'] : array();\n        $stat['disabled'] = $this->disabled;\n        if (isset($this->options['netkey'])) {\n            $stat['netkey'] = $this->options['netkey'];\n        }\n        return $stat;\n    }\n\n    /**\n     * Put file stat in cache and return it\n     *\n     * @param  string  $path   file path\n     * @param  array   $stat   file stat\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function updateCache($path, $stat) {\n        if (empty($stat) || !is_array($stat)) {\n            return $this->cache[$path] = array();\n        }\n\n        $stat['hash'] = $this->encode($path);\n\n        $root = $path == $this->root;\n        $parent = '';\n\n        if ($root) {\n            $stat = array_merge($stat, $this->getRootStatExtra());\n        } else {\n            if (!isset($stat['name']) || $stat['name'] === '') {\n                $stat['name'] = $this->basenameCE($path);\n            }\n            if (empty($stat['phash'])) {\n                $parent = $this->dirnameCE($path);\n                $stat['phash'] = $this->encode($parent);\n            }\n        }\n\n        // name check\n        if (!$jeName = json_encode($stat['name'])) {\n            return $this->cache[$path] = array();\n        }\n        // fix name if required\n        if ($this->options['utf8fix'] && $this->options['utf8patterns'] && $this->options['utf8replace']) {\n            $stat['name'] = json_decode(str_replace($this->options['utf8patterns'], $this->options['utf8replace'], $jeName));\n        }\n\n\n        if (empty($stat['mime'])) {\n            $stat['mime'] = $this->mimetype($stat['name']);\n        }\n\n        // @todo move dateformat to client\n        // $stat['date'] = isset($stat['ts'])\n        // \t? $this->formatDate($stat['ts'])\n        // \t: 'unknown';\n\n        if (!isset($stat['size'])) {\n            $stat['size'] = 'unknown';\n        }\n\n        if ($isDir = ($stat['mime'] === 'directory')) {\n            $stat['volumeid'] = $this->id;\n        }\n\n        $stat['read']  = intval($this->attr($path, 'read', isset($stat['read']) ? !!$stat['read'] : null, $isDir));\n        $stat['write'] = intval($this->attr($path, 'write', isset($stat['write']) ? !!$stat['write'] : null, $isDir));\n        if ($root) {\n            $stat['locked'] = 1;\n        } else {\n            // lock when parent directory is not writable\n            if (!isset($stat['locked'])) {\n                $parent = $this->dirnameCE($path);\n                $pstat = isset($this->cache[$parent])? $this->cache[$parent] : array();\n                if (isset($pstat['write']) && !$pstat['write']) {\n                    $stat['locked'] = true;\n                }\n            }\n            if ($this->attr($path, 'locked', isset($stat['locked']) ? !!$stat['locked'] : null, $isDir)) {\n                $stat['locked'] = 1;\n            } else {\n                unset($stat['locked']);\n            }\n        }\n\n        if ($root) {\n            unset($stat['hidden']);\n        } elseif ($this->attr($path, 'hidden', isset($stat['hidden']) ? !!$stat['hidden'] : null, $isDir)\n            || !$this->mimeAccepted($stat['mime'])) {\n            $stat['hidden'] = 1;\n        } else {\n            unset($stat['hidden']);\n        }\n\n        if ($stat['read'] && empty($stat['hidden'])) {\n\n            if ($isDir) {\n                // caching parent's subdirs\n                if ($parent) {\n                    $this->subdirsCache[$parent] = true;\n                }\n                // for dir - check for subdirs\n                if ($this->options['checkSubfolders']) {\n                    if (isset($stat['dirs'])) {\n                        if ($stat['dirs']) {\n                            $stat['dirs'] = 1;\n                        } else {\n                            unset($stat['dirs']);\n                        }\n                    } elseif (!empty($stat['alias']) && !empty($stat['target'])) {\n                        $stat['dirs'] = isset($this->cache[$stat['target']])\n                            ? intval(isset($this->cache[$stat['target']]['dirs']))\n                            : $this->subdirsCE($stat['target']);\n\n                    } elseif ($this->subdirsCE($path)) {\n                        $stat['dirs'] = 1;\n                    }\n                } else {\n                    $stat['dirs'] = 1;\n                }\n            } else {\n                // for files - check for thumbnails\n                $p = isset($stat['target']) ? $stat['target'] : $path;\n                if ($this->tmbURL && !isset($stat['tmb']) && $this->canCreateTmb($p, $stat)) {\n                    $tmb = $this->gettmb($p, $stat);\n                    $stat['tmb'] = $tmb ? $tmb : 1;\n                }\n\n            }\n            if (!isset($stat['url']) && $this->URL && $this->encoding) {\n                $_path = str_replace($this->separator, '/', substr($path, strlen($this->root) + 1));\n                $stat['url'] = rtrim($this->URL, '/') . '/' . str_replace('%2F', '/', rawurlencode((substr(PHP_OS, 0, 3) === 'WIN')? $_path : $this->convEncIn($_path, true)));\n            }\n        } else {\n            if ($isDir) {\n                unset($stat['dirs']);\n            }\n        }\n\n        if (!empty($stat['alias']) && !empty($stat['target'])) {\n            $stat['thash'] = $this->encode($stat['target']);\n            //$this->cache[$stat['target']] = $stat;\n            unset($stat['target']);\n        }\n\n        if (isset($this->options['netkey']) && $path === $this->root) {\n            $stat['netkey'] = $this->options['netkey'];\n        }\n\n        return $this->cache[$path] = $stat;\n    }\n\n    /**\n     * Get stat for folder content and put in cache\n     *\n     * @param  string  $path\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function cacheDir($path) {\n        $this->dirsCache[$path] = array();\n        $this->subdirsCache[$path] = false;\n\n        foreach ($this->scandirCE($path) as $p) {\n            if (($stat = $this->stat($p)) && empty($stat['hidden'])) {\n                if ($stat['mime'] === 'directory') {\n                    $this->subdirsCache[$path] = true;\n                }\n                $this->dirsCache[$path][] = $p;\n            }\n        }\n    }\n\n    /**\n     * Clean cache\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function clearcache() {\n        $this->cache = $this->dirsCache = array();\n        $this->sessionRestart();\n        unset($this->sessionCache['rootstat'][md5($this->root)]);\n        ElFinder::sessionWrite();\n    }\n\n    /**\n     * Return file mimetype\n     *\n     * @param  string  $path  file path\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function mimetype($path, $name = '') {\n        $type = '';\n\n        if ($name === '') {\n            $name = $path;\n        }\n        $ext = (false === $pos = strrpos($name, '.')) ? '' : substr($name, $pos + 1);\n        if ($this->mimeDetect == 'finfo') {\n            if ($type = @finfo_file($this->finfo, $path)) {\n                if ($ext && preg_match('~^application/(?:octet-stream|(?:x-)?zip)~', $type)) {\n                    if (isset(ElFinderVolumeDriver::$mimetypes[$ext])) $type = ElFinderVolumeDriver::$mimetypes[$ext];\n                } else if ($ext === 'js' && preg_match('~^text/~', $type)) {\n                    $type = 'text/javascript';\n                }\n            } else {\n                $type = 'unknown';\n            }\n        } elseif ($this->mimeDetect == 'mime_content_type') {\n            $type = mime_content_type($path);\n        } else {\n            $type = ElFinderVolumeDriver::mimetypeInternalDetect($path);\n        }\n\n        $type = explode(';', $type);\n        $type = trim($type[0]);\n\n        if (in_array($type, array('application/x-empty', 'inode/x-empty'))) {\n            // finfo return this mime for empty files\n            $type = 'text/plain';\n        } elseif ($type == 'application/x-zip') {\n            // http://elrte.org/redmine/issues/163\n            $type = 'application/zip';\n        }\n\n        // mime type normalization\n        $_checkKey = strtolower($ext.':'.$type);\n        if (isset($this->options['mimeMap'][$_checkKey])) {\n            $type = $this->options['mimeMap'][$_checkKey];\n        }\n\n        return $type == 'unknown' && $this->mimeDetect != 'internal'\n            ? ElFinderVolumeDriver::mimetypeInternalDetect($path)\n            : $type;\n\n    }\n\n    /**\n     * Detect file mimetype using \"internal\" method\n     *\n     * @param  string  $path  file path\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    static protected function mimetypeInternalDetect($path) {\n        // load default MIME table file \"mime.types\"\n        if (!ElFinderVolumeDriver::$mimetypesLoaded) {\n            ElFinderVolumeDriver::$mimetypesLoaded = true;\n            $file = dirname(__FILE__).DIRECTORY_SEPARATOR.'mime.types';\n            if (is_readable($file)) {\n                $mimecf = file($file);\n                foreach ($mimecf as $line_num => $line) {\n                    if (!preg_match('/^\\s*#/', $line)) {\n                        $mime = preg_split('/\\s+/', $line, -1, PREG_SPLIT_NO_EMPTY);\n                        for ($i = 1, $size = count($mime); $i < $size ; $i++) {\n                            if (!isset(ElFinderVolumeDriver::$mimetypes[$mime[$i]])) {\n                                ElFinderVolumeDriver::$mimetypes[$mime[$i]] = $mime[0];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        $pinfo = pathinfo($path);\n        $ext   = isset($pinfo['extension']) ? strtolower($pinfo['extension']) : '';\n        return isset(ElFinderVolumeDriver::$mimetypes[$ext]) ? ElFinderVolumeDriver::$mimetypes[$ext] : 'unknown';\n    }\n\n    /**\n     * Return file/total directory size\n     *\n     * @param  string  $path  file path\n     * @return int\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function countSize($path) {\n        $stat = $this->stat($path);\n\n        if (empty($stat) || !$stat['read'] || !empty($stat['hidden'])) {\n            return 'unknown';\n        }\n\n        if ($stat['mime'] != 'directory') {\n            return $stat['size'];\n        }\n\n        $subdirs = $this->options['checkSubfolders'];\n        $this->options['checkSubfolders'] = true;\n        $result = 0;\n        foreach ($this->getScandir($path) as $stat) {\n            $size = $stat['mime'] == 'directory' && $stat['read']\n                ? $this->countSize($this->joinPathCE($path, $stat['name']))\n                : (isset($stat['size']) ? intval($stat['size']) : 0);\n            if ($size > 0) {\n                $result += $size;\n            }\n        }\n        $this->options['checkSubfolders'] = $subdirs;\n        return $result;\n    }\n\n    /**\n     * Return true if all mimes is directory or files\n     *\n     * @param  string  $mime1  mimetype\n     * @param  string  $mime2  mimetype\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function isSameType($mime1, $mime2) {\n        return ($mime1 == 'directory' && $mime1 == $mime2) || ($mime1 != 'directory' && $mime2 != 'directory');\n    }\n\n    /**\n     * If file has required attr == $val - return file path,\n     * If dir has child with has required attr == $val - return child path\n     *\n     * @param  string   $path  file path\n     * @param  string   $attr  attribute name\n     * @param  bool     $val   attribute value\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function closestByAttr($path, $attr, $val) {\n        $stat = $this->stat($path);\n\n        if (empty($stat)) {\n            return false;\n        }\n\n        $v = isset($stat[$attr]) ? $stat[$attr] : false;\n\n        if ($v == $val) {\n            return $path;\n        }\n\n        return $stat['mime'] == 'directory'\n            ? $this->childsByAttr($path, $attr, $val)\n            : false;\n    }\n\n    /**\n     * Return first found children with required attr == $val\n     *\n     * @param  string   $path  file path\n     * @param  string   $attr  attribute name\n     * @param  bool     $val   attribute value\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function childsByAttr($path, $attr, $val) {\n        foreach ($this->scandirCE($path) as $p) {\n            if (($_p = $this->closestByAttr($p, $attr, $val)) != false) {\n                return $_p;\n            }\n        }\n        return false;\n    }\n\n    protected function isMyReload($target = '', $ARGtarget = '') {\n        if (! empty($this->ARGS['cmd']) && $this->ARGS['cmd'] === 'parents') {\n            return true;\n        }\n        if (! empty($this->ARGS['reload'])) {\n            if ($ARGtarget === '') {\n                $ARGtarget = isset($this->ARGS['target'])? $this->ARGS['target']\n                    : ((isset($this->ARGS['targets']) && is_array($this->ARGS['targets']) && count($this->ARGS['targets']) === 1)?\n                        $this->ARGS['targets'][0] : '');\n            }\n            if ($ARGtarget !== '') {\n                $ARGtarget = strval($ARGtarget);\n                if ($target === '') {\n                    return (strpos($ARGtarget, $this->id) === 0);\n                } else {\n                    $target = strval($target);\n                    return ($target === $ARGtarget);\n                }\n            }\n        }\n        return false;\n    }\n\n    /*****************  get content *******************/\n\n    /**\n     * Return required dir's files info.\n     * If onlyMimes is set - return only dirs and files of required mimes\n     *\n     * @param  string  $path  dir path\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function getScandir($path) {\n        $files = array();\n\n        !isset($this->dirsCache[$path]) && $this->cacheDir($path);\n\n        foreach ($this->dirsCache[$path] as $p) {\n            if (($stat = $this->stat($p)) && empty($stat['hidden'])) {\n                $files[] = $stat;\n            }\n        }\n\n        return $files;\n    }\n\n\n    /**\n     * Return subdirs tree\n     *\n     * @param  string  $path  parent dir path\n     * @param  int     $deep  tree deep\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function gettree($path, $deep, $exclude='') {\n        $dirs = array();\n\n        !isset($this->dirsCache[$path]) && $this->cacheDir($path);\n\n        foreach ($this->dirsCache[$path] as $p) {\n            $stat = $this->stat($p);\n\n            if ($stat && empty($stat['hidden']) && $p != $exclude && $stat['mime'] == 'directory') {\n                $dirs[] = $stat;\n                if ($deep > 0 && !empty($stat['dirs'])) {\n                    $dirs = array_merge($dirs, $this->gettree($p, $deep-1));\n                }\n            }\n        }\n\n        return $dirs;\n    }\n\n    /**\n     * Recursive files search\n     *\n     * @param  string  $path   dir path\n     * @param  string  $q      search string\n     * @param  array   $mimes\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function doSearch($path, $q, $mimes) {\n        $result = array();\n\n        $timeout = $this->options['searchTimeout']? $this->searchStart + $this->options['searchTimeout'] : 0;\n        if ($timeout && $timeout < time()) {\n            $this->setError(ElFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode($path)));\n            return $result;\n        }\n\n        foreach($this->scandirCE($path) as $p) {\n            @set_time_limit($this->options['searchTimeout'] + 30);\n\n            if ($timeout && ($this->error || $timeout < time())) {\n                !$this->error && $this->setError(ElFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode($path)));\n                break;\n            }\n\n\n            $stat = $this->stat($p);\n\n            if (!$stat) { // invalid links\n                continue;\n            }\n\n            if (!empty($stat['hidden']) || !$this->mimeAccepted($stat['mime'], $mimes)) {\n                continue;\n            }\n\n            $name = $stat['name'];\n\n            if ((!$mimes || $stat['mime'] !== 'directory') && $this->stripos($name, $q) !== false) {\n                $stat['path'] = $this->path($stat['hash']);\n                if ($this->URL && !isset($stat['url'])) {\n                    $path = str_replace($this->separator, '/', substr($p, strlen($this->root) + 1));\n                    if ($this->encoding) {\n                        $path = str_replace('%2F', '/', rawurlencode($this->convEncIn($path, true)));\n                    }\n                    $stat['url'] = $this->URL . $path;\n                }\n\n                $result[] = $stat;\n            }\n            if ($stat['mime'] == 'directory' && $stat['read'] && !isset($stat['alias'])) {\n                $result = array_merge($result, $this->doSearch($p, $q, $mimes));\n            }\n        }\n\n        return $result;\n    }\n\n    /**********************  manuipulations  ******************/\n\n    /**\n     * Copy file/recursive copy dir only in current volume.\n     * Return new file path or false.\n     *\n     * @param  string  $src   source path\n     * @param  string  $dst   destination dir path\n     * @param  string  $name  new file name (optionaly)\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function copy($src, $dst, $name) {\n        $srcStat = $this->stat($src);\n        $this->clearcache();\n\n        if (!empty($srcStat['thash'])) {\n            $target = $this->decode($srcStat['thash']);\n            if (!$this->inpathCE($target, $this->root)) {\n                return $this->setError(ElFinder::ERROR_COPY, $this->path($srcStat['hash']), ElFinder::ERROR_MKOUTLINK);\n            }\n            $stat   = $this->stat($target);\n            $this->clearcache();\n            return $stat && $this->symlinkCE($target, $dst, $name)\n                ? $this->joinPathCE($dst, $name)\n                : $this->setError(ElFinder::ERROR_COPY, $this->path($srcStat['hash']));\n        }\n\n        if ($srcStat['mime'] == 'directory') {\n            $test = $this->stat($this->joinPathCE($dst, $name));\n\n            if (($test && $test['mime'] != 'directory') || $this->convEncOut(!$this->_mkdir($this->convEncIn($dst), $this->convEncIn($name)))) {\n                return $this->setError(ElFinder::ERROR_COPY, $this->path($srcStat['hash']));\n            }\n\n            $dst = $this->joinPathCE($dst, $name);\n\n            foreach ($this->getScandir($src) as $stat) {\n                if (empty($stat['hidden'])) {\n                    $name = $stat['name'];\n                    if (!$this->copy($this->joinPathCE($src, $name), $dst, $name)) {\n                        $this->remove($dst, true); // fall back\n                        return $this->setError($this->error, ElFinder::ERROR_COPY, $this->_path($src));\n                    }\n                }\n            }\n            $this->clearcache();\n            return $dst;\n        }\n\n        return $this->convEncOut($this->_copy($this->convEncIn($src), $this->convEncIn($dst), $this->convEncIn($name)))\n            ? $this->joinPathCE($dst, $name)\n            : $this->setError(ElFinder::ERROR_COPY, $this->path($srcStat['hash']));\n    }\n\n    /**\n     * Move file\n     * Return new file path or false.\n     *\n     * @param  string  $src   source path\n     * @param  string  $dst   destination dir path\n     * @param  string  $name  new file name\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function move($src, $dst, $name) {\n        $stat = $this->stat($src);\n        $stat['realpath'] = $src;\n        $this->rmTmb($stat); // can not do rmTmb() after _move()\n        $this->clearcache();\n\n        if ($this->convEncOut($this->_move($this->convEncIn($src), $this->convEncIn($dst), $this->convEncIn($name)))) {\n            $this->removed[] = $stat;\n\n            return $this->joinPathCE($dst, $name);\n        }\n\n        return $this->setError(ElFinder::ERROR_MOVE, $this->path($stat['hash']));\n    }\n\n    /**\n     * Copy file from another volume.\n     * Return new file path or false.\n     *\n     * @param  Object  $volume       source volume\n     * @param  string  $src          source file hash\n     * @param  string  $destination  destination dir path\n     * @param  string  $name         file name\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function copyFrom($volume, $src, $destination, $name) {\n\n        if (($source = $volume->file($src)) == false) {\n            return $this->setError(ElFinder::ERROR_COPY, '#'.$src, $volume->error());\n        }\n\n        $errpath = $volume->path($source['hash']);\n\n        if (!$this->nameAccepted($source['name'])) {\n            return $this->setError(ElFinder::ERROR_COPY, $errpath, ElFinder::ERROR_INVALID_NAME);\n        }\n\n        if (!$source['read']) {\n            return $this->setError(ElFinder::ERROR_COPY, $errpath, ElFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($source['mime'] == 'directory') {\n            $stat = $this->stat($this->joinPathCE($destination, $name));\n            $this->clearcache();\n            if ((!$stat || $stat['mime'] != 'directory') && $this->convEncOut(!$this->_mkdir($this->convEncIn($destination), $this->convEncIn($name)))) {\n                return $this->setError(ElFinder::ERROR_COPY, $errpath);\n            }\n\n            $path = $this->joinPathCE($destination, $name);\n\n            foreach ($volume->scandir($src) as $entr) {\n                if (!$this->copyFrom($volume, $entr['hash'], $path, $entr['name'])) {\n                    $this->remove($path, true); // fall back\n                    return $this->setError($this->error, ElFinder::ERROR_COPY, $errpath);\n                }\n            }\n\n        } else {\n            // $mime = $source['mime'];\n            // $w = $h = 0;\n            if (($dim = $volume->dimensions($src))) {\n                $s = explode('x', $dim);\n                $source['width']  = $s[0];\n                $source['height'] = $s[1];\n            }\n\n            if (($fp = $volume->open($src)) == false\n                || ($path = $this->saveCE($fp, $destination, $name, $source)) == false) {\n                $fp && $volume->close($fp, $src);\n                return $this->setError(ElFinder::ERROR_COPY, $errpath);\n            }\n            $volume->close($fp, $src);\n\n            // MIME check\n            $stat = $this->stat($path);\n            $mimeByName = ElFinderVolumeDriver::mimetypeInternalDetect($stat['name']);\n            if ($stat['mime'] === $mimeByName) {\n                $mimeByName = '';\n            }\n            if (!$this->allowPutMime($stat['mime']) || ($mimeByName && $mimeByName !== 'unknown' && !$this->allowPutMime($mimeByName))) {\n                $this->remove($path, true);\n                return $this->setError(ElFinder::ERROR_UPLOAD_FILE_MIME, $errpath);\n            }\n        }\n\n        return $path;\n    }\n\n    /**\n     * Remove file/ recursive remove dir\n     *\n     * @param  string  $path   file path\n     * @param  bool    $force  try to remove even if file locked\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function remove($path, $force = false) {\n        $stat = $this->stat($path);\n\n        if (empty($stat)) {\n            return $this->setError(ElFinder::ERROR_RM, $this->path($stat['hash']), ElFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        $stat['realpath'] = $path;\n        $this->rmTmb($stat);\n        $this->clearcache();\n\n        if (!$force && !empty($stat['locked'])) {\n            return $this->setError(ElFinder::ERROR_LOCKED, $this->path($stat['hash']));\n        }\n\n        if ($stat['mime'] == 'directory' && empty($stat['thash'])) {\n            $ret = $this->delTree($this->convEncIn($path));\n            $this->convEncOut();\n            if (!$ret) {\n                return $this->setError(ElFinder::ERROR_RM, $this->path($stat['hash']));\n            }\n        } else {\n            if ($this->convEncOut(!$this->_unlink($this->convEncIn($path)))) {\n                return $this->setError(ElFinder::ERROR_RM, $this->path($stat['hash']));\n            }\n        }\n\n        $this->removed[] = $stat;\n        return true;\n    }\n\n\n    /************************* thumbnails **************************/\n\n    /**\n     * Return thumbnail file name for required file\n     *\n     * @param  array  $stat  file stat\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function tmbname($stat) {\n        return $stat['hash'].$stat['ts'].'.png';\n    }\n\n    /**\n     * Return thumnbnail name if exists\n     *\n     * @param  string  $path file path\n     * @param  array   $stat file stat\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function gettmb($path, $stat) {\n        if ($this->tmbURL && $this->tmbPath) {\n            // file itself thumnbnail\n            if (strpos($path, $this->tmbPath) === 0) {\n                return basename($path);\n            }\n\n            $name = $this->tmbname($stat);\n            if (file_exists($this->tmbPath.DIRECTORY_SEPARATOR.$name)) {\n                return $name;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return true if thumnbnail for required file can be created\n     *\n     * @param  string  $path  thumnbnail path\n     * @param  array   $stat  file stat\n     * @param  bool    $checkTmbPath\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function canCreateTmb($path, $stat, $checkTmbPath = true) {\n        return (!$checkTmbPath || $this->tmbPathWritable)\n        && (!$this->tmbPath || strpos($path, $this->tmbPath) === false) // do not create thumnbnail for thumnbnail\n        && $this->imgLib\n        && strpos($stat['mime'], 'image') === 0\n        && ($this->imgLib == 'gd' ? in_array($stat['mime'], array('image/jpeg', 'image/png', 'image/gif', 'image/x-ms-bmp')) : true);\n    }\n\n    /**\n     * Return true if required file can be resized.\n     * By default - the same as canCreateTmb\n     *\n     * @param  string  $path  thumnbnail path\n     * @param  array   $stat  file stat\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function canResize($path, $stat) {\n        return $this->canCreateTmb($path, $stat, false);\n    }\n\n    /**\n     * Create thumnbnail and return it's URL on success\n     *\n     * @param  string  $path  file path\n     * @param  string  $mime  file mime type\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function createTmb($path, $stat) {\n        if (!$stat || !$this->canCreateTmb($path, $stat)) {\n            return false;\n        }\n\n        $name = $this->tmbname($stat);\n        $tmb  = $this->tmbPath.DIRECTORY_SEPARATOR.$name;\n\n        // copy image into tmbPath so some drivers does not store files on local fs\n        if (($src = $this->fopenCE($path, 'rb')) == false) {\n            return false;\n        }\n\n        if (($trg = fopen($tmb, 'wb')) == false) {\n            $this->fcloseCE($src, $path);\n            return false;\n        }\n\n        while (!feof($src)) {\n            fwrite($trg, fread($src, 8192));\n        }\n\n        $this->fcloseCE($src, $path);\n        fclose($trg);\n        @chmod($path, $this->options['fileMode']);\n\n        $result = false;\n\n        $tmbSize = $this->tmbSize;\n\n        if (($s = getimagesize($tmb)) == false) {\n            return false;\n        }\n\n        /* If image smaller or equal thumbnail size - just fitting to thumbnail square */\n        if ($s[0] <= $tmbSize && $s[1]\t<= $tmbSize) {\n            $result = $this->imgSquareFit($tmb, $tmbSize, $tmbSize, 'center', 'middle', $this->options['tmbBgColor'], 'png' );\n        } else {\n\n            if ($this->options['tmbCrop']) {\n\n                $result = $tmb;\n                /* Resize and crop if image bigger than thumbnail */\n                if (!(($s[0] > $tmbSize && $s[1] <= $tmbSize) || ($s[0] <= $tmbSize && $s[1] > $tmbSize) ) || ($s[0] > $tmbSize && $s[1] > $tmbSize)) {\n                    $result = $this->imgResize($tmb, $tmbSize, $tmbSize, true, false, 'png');\n                }\n\n                if ($result && ($s = getimagesize($tmb)) != false) {\n                    $x = $s[0] > $tmbSize ? intval(($s[0] - $tmbSize)/2) : 0;\n                    $y = $s[1] > $tmbSize ? intval(($s[1] - $tmbSize)/2) : 0;\n                    $result = $this->imgCrop($result, $tmbSize, $tmbSize, $x, $y, 'png');\n                } else {\n                    $result = false;\n                }\n\n            } else {\n                $result = $this->imgResize($tmb, $tmbSize, $tmbSize, true, true, 'png');\n            }\n\n            if ($result) {\n                $result = $this->imgSquareFit($result, $tmbSize, $tmbSize, 'center', 'middle', $this->options['tmbBgColor'], 'png' );\n            }\n        }\n\n        if (!$result) {\n            unlink($tmb);\n            return false;\n        }\n\n        return $name;\n    }\n\n    /**\n     * Resize image\n     *\n     * @param  string   $path               image file\n     * @param  int      $width              new width\n     * @param  int      $height             new height\n     * @param  bool\t    $keepProportions    crop image\n     * @param  bool\t    $resizeByBiggerSide resize image based on bigger side if true\n     * @param  string   $destformat         image destination format\n     * @param  int      $jpgQuality         JEPG quality (1-100)\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     **/\n    protected function imgResize($path, $width, $height, $keepProportions = false, $resizeByBiggerSide = true, $destformat = null, $jpgQuality = null) {\n        if (($s = @getimagesize($path)) == false) {\n            return false;\n        }\n\n        $result = false;\n\n        list($size_w, $size_h) = array($width, $height);\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        if ($keepProportions == true) {\n\n            list($orig_w, $orig_h) = array($s[0], $s[1]);\n\n            /* Resizing by biggest side */\n            if ($resizeByBiggerSide) {\n                if ($orig_w > $orig_h) {\n                    $size_h = round($orig_h * $width / $orig_w);\n                    $size_w = $width;\n                } else {\n                    $size_w = round($orig_w * $height / $orig_h);\n                    $size_h = $height;\n                }\n            } else {\n                if ($orig_w > $orig_h) {\n                    $size_w = round($orig_w * $height / $orig_h);\n                    $size_h = $height;\n                } else {\n                    $size_h = round($orig_h * $width / $orig_w);\n                    $size_w = $width;\n                }\n            }\n        }\n\n        switch ($this->imgLib) {\n            case 'imagick':\n\n                try {\n                    $img = new imagick($path);\n                } catch (Exception $e) {\n                    return false;\n                }\n\n                // Imagick::FILTER_BOX faster than FILTER_LANCZOS so use for createTmb\n                // resize bench: http://app-mgng.rhcloud.com/9\n                // resize sample: http://www.dylanbeattie.net/magick/filters/result.html\n                $filter = ($destformat === 'png' /* createTmb */)? Imagick::FILTER_BOX : Imagick::FILTER_LANCZOS;\n\n                $ani = ($img->getNumberImages() > 1);\n                if ($ani && is_null($destformat)) {\n                    $img = $img->coalesceImages();\n                    do {\n                        $img->resizeImage($size_w, $size_h, $filter, 1);\n                    } while ($img->nextImage());\n                    $img = $img->optimizeImageLayers();\n                    $result = $img->writeImages($path, true);\n                } else {\n                    if ($ani) {\n                        $img->setFirstIterator();\n                    }\n                    $img->resizeImage($size_w, $size_h, $filter, 1);\n                    $result = $this->imagickImage($img, $path, $destformat, $jpgQuality);\n                }\n\n                $img->destroy();\n\n                return $result ? $path : false;\n\n                break;\n\n            case 'gd':\n                $img = $this->gdImageCreate($path,$s['mime']);\n\n                if ($img &&  false != ($tmp = imagecreatetruecolor($size_w, $size_h))) {\n\n                    $this->gdImageBackground($tmp,$this->options['tmbBgColor']);\n\n                    if (!imagecopyresampled($tmp, $img, 0, 0, 0, 0, $size_w, $size_h, $s[0], $s[1])) {\n                        return false;\n                    }\n\n                    $result = $this->gdImage($tmp, $path, $destformat, $s['mime'], $jpgQuality);\n\n                    imagedestroy($img);\n                    imagedestroy($tmp);\n\n                    return $result ? $path : false;\n\n                }\n                break;\n        }\n\n        return false;\n    }\n\n    /**\n     * Crop image\n     *\n     * @param  string   $path               image file\n     * @param  int      $width              crop width\n     * @param  int      $height             crop height\n     * @param  bool\t    $x                  crop left offset\n     * @param  bool\t    $y                  crop top offset\n     * @param  string   $destformat         image destination format\n     * @param  int      $jpgQuality         JEPG quality (1-100)\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     **/\n    protected function imgCrop($path, $width, $height, $x, $y, $destformat = null, $jpgQuality = null) {\n        if (($s = @getimagesize($path)) == false) {\n            return false;\n        }\n\n        $result = false;\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        switch ($this->imgLib) {\n            case 'imagick':\n\n                try {\n                    $img = new imagick($path);\n                } catch (Exception $e) {\n                    return false;\n                }\n\n                $ani = ($img->getNumberImages() > 1);\n                if ($ani && is_null($destformat)) {\n                    $img = $img->coalesceImages();\n                    do {\n                        $img->setImagePage($s[0], $s[1], 0, 0);\n                        $img->cropImage($width, $height, $x, $y);\n                        $img->setImagePage($width, $height, 0, 0);\n                    } while ($img->nextImage());\n                    $img = $img->optimizeImageLayers();\n                    $result = $img->writeImages($path, true);\n                } else {\n                    if ($ani) {\n                        $img->setFirstIterator();\n                    }\n                    $img->setImagePage($s[0], $s[1], 0, 0);\n                    $img->cropImage($width, $height, $x, $y);\n                    $img->setImagePage($width, $height, 0, 0);\n                    $result = $this->imagickImage($img, $path, $destformat, $jpgQuality);\n                }\n\n                $img->destroy();\n\n                return $result ? $path : false;\n\n                break;\n\n            case 'gd':\n                $img = $this->gdImageCreate($path,$s['mime']);\n\n                if ($img &&  false != ($tmp = imagecreatetruecolor($width, $height))) {\n\n                    $this->gdImageBackground($tmp,$this->options['tmbBgColor']);\n\n                    $size_w = $width;\n                    $size_h = $height;\n\n                    if ($s[0] < $width || $s[1] < $height) {\n                        $size_w = $s[0];\n                        $size_h = $s[1];\n                    }\n\n                    if (!imagecopy($tmp, $img, 0, 0, $x, $y, $size_w, $size_h)) {\n                        return false;\n                    }\n\n                    $result = $this->gdImage($tmp, $path, $destformat, $s['mime'], $jpgQuality);\n\n                    imagedestroy($img);\n                    imagedestroy($tmp);\n\n                    return $result ? $path : false;\n\n                }\n                break;\n        }\n\n        return false;\n    }\n\n    /**\n     * Put image to square\n     *\n     * @param  string   $path               image file\n     * @param  int      $width              square width\n     * @param  int      $height             square height\n     * @param  int\t    $align              reserved\n     * @param  int \t    $valign             reserved\n     * @param  string   $bgcolor            square background color in #rrggbb format\n     * @param  string   $destformat         image destination format\n     * @param  int      $jpgQuality         JEPG quality (1-100)\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     **/\n    protected function imgSquareFit($path, $width, $height, $align = 'center', $valign = 'middle', $bgcolor = '#0000ff', $destformat = null, $jpgQuality = null) {\n        if (($s = @getimagesize($path)) == false) {\n            return false;\n        }\n\n        $result = false;\n\n        /* Coordinates for image over square aligning */\n        $y = ceil(abs($height - $s[1]) / 2);\n        $x = ceil(abs($width - $s[0]) / 2);\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        switch ($this->imgLib) {\n            case 'imagick':\n                try {\n                    $img = new imagick($path);\n                } catch (Exception $e) {\n                    return false;\n                }\n\n                $ani = ($img->getNumberImages() > 1);\n                if ($ani && is_null($destformat)) {\n                    $img1 = new Imagick();\n                    $img1->setFormat('gif');\n                    $img = $img->coalesceImages();\n                    do {\n                        $gif = new Imagick();\n                        $gif->newImage($width, $height, new ImagickPixel($bgcolor));\n                        $gif->setImageColorspace($img->getImageColorspace());\n                        $gif->setImageFormat('gif');\n                        $gif->compositeImage( $img, imagick::COMPOSITE_OVER, $x, $y );\n                        $gif->setImageDelay($img->getImageDelay());\n                        $gif->setImageIterations($img->getImageIterations());\n                        $img1->addImage($gif);\n                        $gif->destroy();\n                    } while ($img->nextImage());\n                    $img1 = $img1->optimizeImageLayers();\n                    $result = $img1->writeImages($path, true);\n                } else {\n                    if ($ani) {\n                        $img->setFirstIterator();\n                    }\n                    $img1 = new Imagick();\n                    $img1->newImage($width, $height, new ImagickPixel($bgcolor));\n                    $img1->setImageColorspace($img->getImageColorspace());\n                    $img1->compositeImage( $img, imagick::COMPOSITE_OVER, $x, $y );\n                    $result = $this->imagickImage($img, $path, $destformat, $jpgQuality);\n                }\n\n                $img1->destroy();\n                $img->destroy();\n                return $result ? $path : false;\n\n                break;\n\n            case 'gd':\n                $img = $this->gdImageCreate($path,$s['mime']);\n\n                if ($img &&  false != ($tmp = imagecreatetruecolor($width, $height))) {\n\n                    $this->gdImageBackground($tmp,$bgcolor);\n\n                    if (!imagecopy($tmp, $img, $x, $y, 0, 0, $s[0], $s[1])) {\n                        return false;\n                    }\n\n                    $result = $this->gdImage($tmp, $path, $destformat, $s['mime'], $jpgQuality);\n\n                    imagedestroy($img);\n                    imagedestroy($tmp);\n\n                    return $result ? $path : false;\n                }\n                break;\n        }\n\n        return false;\n    }\n\n    /**\n     * Rotate image\n     *\n     * @param  string   $path               image file\n     * @param  int      $degree             rotete degrees\n     * @param  string   $bgcolor            square background color in #rrggbb format\n     * @param  string   $destformat         image destination format\n     * @param  int      $jpgQuality         JEPG quality (1-100)\n     * @return string|false\n     * @author nao-pon\n     * @author Troex Nevelin\n     **/\n    protected function imgRotate($path, $degree, $bgcolor = '#ffffff', $destformat = null, $jpgQuality = null) {\n        if (($s = @getimagesize($path)) == false || $degree % 360 === 0) {\n            return false;\n        }\n\n        $result = false;\n\n        // try lossless rotate\n        if ($degree % 90 === 0 && in_array($s[2], array(IMAGETYPE_JPEG, IMAGETYPE_JPEG2000))) {\n            $count = ($degree / 90) % 4;\n            $exiftran = array(\n                1 => '-9',\n                2 => '-1',\n                3 => '-2'\n            );\n            $jpegtran = array(\n                1 => '90',\n                2 => '180',\n                3 => '270'\n            );\n            $quotedPath = escapeshellarg($path);\n            $cmds = array(\n                'exiftran -i '.$exiftran[$count].' '.$path,\n                'jpegtran -rotate '.$jpegtran[$count].' -copy all -outfile '.$quotedPath.' '.$quotedPath\n            );\n            foreach($cmds as $cmd) {\n                if ($this->procExec($cmd) === 0) {\n                    $result = true;\n                    break;\n                }\n            }\n            if ($result) {\n                return $path;\n            }\n        }\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        switch ($this->imgLib) {\n            case 'imagick':\n                try {\n                    $img = new imagick($path);\n                } catch (Exception $e) {\n                    return false;\n                }\n\n                if ($img->getNumberImages() > 1) {\n                    $img = $img->coalesceImages();\n                    do {\n                        $img->rotateImage(new ImagickPixel($bgcolor), $degree);\n                    } while ($img->nextImage());\n                    $img = $img->optimizeImageLayers();\n                    $result = $img->writeImages($path, true);\n                } else {\n                    $img->rotateImage(new ImagickPixel($bgcolor), $degree);\n                    $result = $this->imagickImage($img, $path, $destformat, $jpgQuality);\n                }\n                $img->destroy();\n                return $result ? $path : false;\n\n                break;\n\n            case 'gd':\n                $img = $this->gdImageCreate($path,$s['mime']);\n\n                $degree = 360 - $degree;\n                list($r, $g, $b) = sscanf($bgcolor, \"#%02x%02x%02x\");\n                $bgcolor = imagecolorallocate($img, $r, $g, $b);\n                $tmp = imageRotate($img, $degree, (int)$bgcolor);\n\n                $result = $this->gdImage($tmp, $path, $destformat, $s['mime'], $jpgQuality);\n\n                imageDestroy($img);\n                imageDestroy($tmp);\n\n                return $result ? $path : false;\n\n                break;\n        }\n\n        return false;\n    }\n\n    /**\n     * Execute shell command\n     *\n     * @param  string  $command       command line\n     * @param  array   $output        stdout strings\n     * @param  array   $return_var    process exit code\n     * @param  array   $error_output  stderr strings\n     * @return int     exit code\n     * @author Alexey Sukhotin\n     **/\n    protected function procExec($command , array &$output = null, &$return_var = -1, array &$error_output = null) {\n\n        $descriptorspec = array(\n            0 => array(\"pipe\", \"r\"),  // stdin\n            1 => array(\"pipe\", \"w\"),  // stdout\n            2 => array(\"pipe\", \"w\")   // stderr\n        );\n\n        $process = proc_open($command, $descriptorspec, $pipes, null, null);\n\n        if (is_resource($process)) {\n\n            fclose($pipes[0]);\n\n            $tmpout = '';\n            $tmperr = '';\n\n            $output = stream_get_contents($pipes[1]);\n            $error_output = stream_get_contents($pipes[2]);\n\n            fclose($pipes[1]);\n            fclose($pipes[2]);\n            $return_var = proc_close($process);\n\n\n        }\n\n        return $return_var;\n\n    }\n\n    /**\n     * Remove thumbnail, also remove recursively if stat is directory\n     *\n     * @param  string  $stat  file stat\n     * @return void\n     * @author Dmitry (dio) Levashov\n     * @author Naoki Sawada\n     * @author Troex Nevelin\n     **/\n    protected function rmTmb($stat) {\n        if ($stat['mime'] === 'directory') {\n            foreach ($this->scandirCE($this->decode($stat['hash'])) as $p) {\n                @set_time_limit(30);\n                $name = $this->basenameCE($p);\n                $name != '.' && $name != '..' && $this->rmTmb($this->stat($p));\n            }\n        } else if (!empty($stat['tmb']) && $stat['tmb'] != \"1\") {\n            $tmb = $this->tmbPath.DIRECTORY_SEPARATOR.$stat['tmb'];\n            file_exists($tmb) && @unlink($tmb);\n            clearstatcache();\n        }\n    }\n\n    /**\n     * Create an gd image according to the specified mime type\n     *\n     * @param string $path image file\n     * @param string $mime\n     * @return gd image resource identifier\n     */\n    protected function gdImageCreate($path,$mime){\n        switch($mime){\n            case 'image/jpeg':\n                return @imagecreatefromjpeg($path);\n\n            case 'image/png':\n                return @imagecreatefrompng($path);\n\n            case 'image/gif':\n                return @imagecreatefromgif($path);\n\n            case 'image/x-ms-bmp':\n                if (!function_exists('imagecreatefrombmp')) {\n                    include_once dirname(__FILE__).'/libs/GdBmp.php';\n                }\n                return @imagecreatefrombmp($path);\n\n            case 'image/xbm':\n                return @imagecreatefromxbm($path);\n\n            case 'image/xpm':\n                return @imagecreatefromxpm($path);\n        }\n        return false;\n    }\n\n    /**\n     * Output gd image to file\n     *\n     * @param resource $image gd image resource\n     * @param string $filename The path to save the file to.\n     * @param string $destformat The Image type to use for $filename\n     * @param string $mime The original image mime type\n     * @param int    $jpgQuality  JEPG quality (1-100)\n     */\n    protected function gdImage($image, $filename, $destformat, $mime, $jpgQuality = null ){\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n        if ($destformat == 'jpg' || ($destformat == null && $mime == 'image/jpeg')) {\n            return imagejpeg($image, $filename, $jpgQuality);\n        }\n\n        if ($destformat == 'gif' || ($destformat == null && $mime == 'image/gif')) {\n            return imagegif($image, $filename, 7);\n        }\n\n        return imagepng($image, $filename, 7);\n    }\n\n    /**\n     * Output imagick image to file\n     *\n     * @param resource $img imagick image resource\n     * @param string $filename The path to save the file to.\n     * @param string $destformat The Image type to use for $filename\n     * @param int    $jpgQuality  JEPG quality (1-100)\n     */\n    protected function imagickImage($img, $filename, $destformat, $jpgQuality = null ){\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        try {\n            if ($destformat) {\n                if ($destformat === 'gif') {\n                    $img->setImageFormat('gif');\n                } else if ($destformat === 'png') {\n                    $img->setImageFormat('png');\n                } else if ($destformat === 'jpg') {\n                    $img->setImageFormat('jpeg');\n                }\n            }\n            if (strtoupper($img->getImageFormat()) === 'JPEG') {\n                $img->setImageCompression(imagick::COMPRESSION_JPEG);\n                $img->setImageCompressionQuality($jpgQuality);\n                try {\n                    $orientation = $img->getImageOrientation();\n                } catch (ImagickException $e) {\n                    $orientation = 0;\n                }\n                $img->stripImage();\n                if ($orientation) {\n                    $img->setImageOrientation($orientation);\n                }\n            }\n            $result = $img->writeImage($filename);\n        } catch (Exception $e) {\n            $result = false;\n        }\n\n        return $result;\n\n\n\n        if ($destformat == 'jpg' || ($destformat == null && $mime == 'image/jpeg')) {\n            return imagejpeg($image, $filename, $jpgQuality);\n        }\n\n        if ($destformat == 'gif' || ($destformat == null && $mime == 'image/gif')) {\n            return imagegif($image, $filename, 7);\n        }\n\n        return imagepng($image, $filename, 7);\n    }\n\n    /**\n     * Assign the proper background to a gd image\n     *\n     * @param resource $image gd image resource\n     * @param string $bgcolor background color in #rrggbb format\n     */\n    protected function gdImageBackground($image, $bgcolor){\n\n        if( $bgcolor == 'transparent' ){\n            imagesavealpha($image,true);\n            $bgcolor1 = imagecolorallocatealpha($image, 255, 255, 255, 127);\n\n        }else{\n            list($r, $g, $b) = sscanf($bgcolor, \"#%02x%02x%02x\");\n            $bgcolor1 = imagecolorallocate($image, $r, $g, $b);\n        }\n\n        imagefill($image, 0, 0, $bgcolor1);\n    }\n\n    /*********************** misc *************************/\n\n    /**\n     * Return smart formatted date\n     *\n     * @param  int     $ts  file timestamp\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    // protected function formatDate($ts) {\n    // \tif ($ts > $this->today) {\n    // \t\treturn 'Today '.date($this->options['timeFormat'], $ts);\n    // \t}\n    //\n    // \tif ($ts > $this->yesterday) {\n    // \t\treturn 'Yesterday '.date($this->options['timeFormat'], $ts);\n    // \t}\n    //\n    // \treturn date($this->options['dateFormat'], $ts);\n    // }\n\n    /**\n     * Find position of first occurrence of string in a string with multibyte support\n     *\n     * @param  string  $haystack  The string being checked.\n     * @param  string  $needle    The string to find in haystack.\n     * @param  int     $offset    The search offset. If it is not specified, 0 is used.\n     * @return int|bool\n     * @author Alexey Sukhotin\n     **/\n    protected function stripos($haystack , $needle , $offset = 0) {\n        if (function_exists('mb_stripos')) {\n            return mb_stripos($haystack , $needle , $offset, 'UTF-8');\n        } else if (function_exists('mb_strtolower') && function_exists('mb_strpos')) {\n            return mb_strpos(mb_strtolower($haystack, 'UTF-8'), mb_strtolower($needle, 'UTF-8'), $offset);\n        }\n        return stripos($haystack , $needle , $offset);\n    }\n\n    /**\n     * Get server side available archivers\n     *\n     * @param bool $use_cache\n     * @return array\n     */\n    protected function getArchivers($use_cache = true) {\n\n        $sessionKey = 'ARCHIVERS_CACHE';\n        if ($use_cache && isset($this->sessionCache[$sessionKey]) && is_array($this->sessionCache[$sessionKey])) {\n            return $this->sessionCache[$sessionKey];\n        }\n\n        $arcs = array(\n            'create'  => array(),\n            'extract' => array()\n        );\n\n        if (function_exists('proc_open')) {\n\n            $this->procExec('tar --version', $o, $ctar);\n\n            if ($ctar == 0) {\n                $arcs['create']['application/x-tar']  = array('cmd' => 'tar', 'argc' => '-cf', 'ext' => 'tar');\n                $arcs['extract']['application/x-tar'] = array('cmd' => 'tar', 'argc' => '-xf', 'ext' => 'tar');\n                unset($o);\n                $test = $this->procExec('gzip --version', $o, $c);\n                if ($c == 0) {\n                    $arcs['create']['application/x-gzip']  = array('cmd' => 'tar', 'argc' => '-czf', 'ext' => 'tgz');\n                    $arcs['extract']['application/x-gzip'] = array('cmd' => 'tar', 'argc' => '-xzf', 'ext' => 'tgz');\n                }\n                unset($o);\n                $test = $this->procExec('bzip2 --version', $o, $c);\n                if ($c == 0) {\n                    $arcs['create']['application/x-bzip2']  = array('cmd' => 'tar', 'argc' => '-cjf', 'ext' => 'tbz');\n                    $arcs['extract']['application/x-bzip2'] = array('cmd' => 'tar', 'argc' => '-xjf', 'ext' => 'tbz');\n                }\n                unset($o);\n                $test = $this->procExec('xz --version', $o, $c);\n                if ($c == 0) {\n                    $arcs['create']['application/x-xz']  = array('cmd' => 'tar', 'argc' => '-cJf', 'ext' => 'xz');\n                    $arcs['extract']['application/x-xz'] = array('cmd' => 'tar', 'argc' => '-xJf', 'ext' => 'xz');\n                }\n            }\n            unset($o);\n            $this->procExec('zip -v', $o, $c);\n            if ($c == 0) {\n                $arcs['create']['application/zip']  = array('cmd' => 'zip', 'argc' => '-r9', 'ext' => 'zip');\n            }\n            unset($o);\n            $this->procExec('unzip --help', $o, $c);\n            if ($c == 0) {\n                $arcs['extract']['application/zip'] = array('cmd' => 'unzip', 'argc' => '',  'ext' => 'zip');\n            }\n            unset($o);\n            $this->procExec('rar --version', $o, $c);\n            if ($c == 0 || $c == 7) {\n                $arcs['create']['application/x-rar']  = array('cmd' => 'rar', 'argc' => 'a -inul', 'ext' => 'rar');\n                $arcs['extract']['application/x-rar'] = array('cmd' => 'rar', 'argc' => 'x -y',    'ext' => 'rar');\n            } else {\n                unset($o);\n                $test = $this->procExec('unrar', $o, $c);\n                if ($c==0 || $c == 7) {\n                    $arcs['extract']['application/x-rar'] = array('cmd' => 'unrar', 'argc' => 'x -y', 'ext' => 'rar');\n                }\n            }\n            unset($o);\n            $this->procExec('7za --help', $o, $c);\n            if ($c == 0) {\n                $arcs['create']['application/x-7z-compressed']  = array('cmd' => '7za', 'argc' => 'a', 'ext' => '7z');\n                $arcs['extract']['application/x-7z-compressed'] = array('cmd' => '7za', 'argc' => 'x -y', 'ext' => '7z');\n\n                if (empty($arcs['create']['application/zip'])) {\n                    $arcs['create']['application/zip'] = array('cmd' => '7za', 'argc' => 'a -tzip', 'ext' => 'zip');\n                }\n                if (empty($arcs['extract']['application/zip'])) {\n                    $arcs['extract']['application/zip'] = array('cmd' => '7za', 'argc' => 'x -tzip -y', 'ext' => 'zip');\n                }\n                if (empty($arcs['create']['application/x-tar'])) {\n                    $arcs['create']['application/x-tar'] = array('cmd' => '7za', 'argc' => 'a -ttar', 'ext' => 'tar');\n                }\n                if (empty($arcs['extract']['application/x-tar'])) {\n                    $arcs['extract']['application/x-tar'] = array('cmd' => '7za', 'argc' => 'x -ttar -y', 'ext' => 'tar');\n                }\n            } else if (substr(PHP_OS,0,3) === 'WIN') {\n                // check `7z` for Windows server.\n                unset($o);\n                $this->procExec('7z', $o, $c);\n                if ($c == 0) {\n                    $arcs['create']['application/x-7z-compressed']  = array('cmd' => '7z', 'argc' => 'a', 'ext' => '7z');\n                    $arcs['extract']['application/x-7z-compressed'] = array('cmd' => '7z', 'argc' => 'x -y', 'ext' => '7z');\n\n                    if (empty($arcs['create']['application/zip'])) {\n                        $arcs['create']['application/zip'] = array('cmd' => '7z', 'argc' => 'a -tzip', 'ext' => 'zip');\n                    }\n                    if (empty($arcs['extract']['application/zip'])) {\n                        $arcs['extract']['application/zip'] = array('cmd' => '7z', 'argc' => 'x -tzip -y', 'ext' => 'zip');\n                    }\n                    if (empty($arcs['create']['application/x-tar'])) {\n                        $arcs['create']['application/x-tar'] = array('cmd' => '7z', 'argc' => 'a -ttar', 'ext' => 'tar');\n                    }\n                    if (empty($arcs['extract']['application/x-tar'])) {\n                        $arcs['extract']['application/x-tar'] = array('cmd' => '7z', 'argc' => 'x -ttar -y', 'ext' => 'tar');\n                    }\n                }\n            }\n\n        }\n\n        // Use PHP ZipArchive Class\n        if (class_exists('ZipArchive', false)) {\n            if (empty($arcs['create']['application/zip'])) {\n                $arcs['create']['application/zip']  = array('cmd' => 'phpfunction', 'argc' => 'self::zipArchiveZip', 'ext' => 'zip');\n            }\n            if (empty($arcs['extract']['application/zip'])) {\n                $arcs['extract']['application/zip'] = array('cmd' => 'phpfunction', 'argc' => 'self::zipArchiveUnzip', 'ext' => 'zip');\n            }\n        }\n\n        $this->sessionCache[$sessionKey] = $arcs;\n        return $arcs;\n    }\n\n    /**\n     * Resolve relative / (Unix-like)absolute path\n     *\n     * @param string $path  target path\n     * @param string $base  base path\n     * @return string\n     */\n    protected function getFullPath($path, $base) {\n        $separator = $this->separator;\n        $systemroot = $this->systemRoot;\n\n        $sepquoted = preg_quote($separator, '#');\n\n        // normalize `/../`\n        $normreg = '#('.$sepquoted.')[^'.$sepquoted.']+'.$sepquoted.'\\.\\.'.$sepquoted.'#';\n        while(preg_match($normreg, $path)) {\n            $path = preg_replace($normreg, '$1', $path);\n        }\n\n        // 'Here'\n        if ($path === '' || $path === '.' . $separator) return $base;\n\n        // Absolute path\n        if ($path[0] === $separator || strpos($path, $systemroot) === 0) {\n            return $path;\n        }\n\n        $preg_separator = '#' . $sepquoted . '#';\n\n        // Relative path from 'Here'\n        if (substr($path, 0, 2) === '.' . $separator || $path[0] !== '.' || substr($path, 0, 3) !== '..' . $separator) {\n            $arrn = preg_split($preg_separator, $path, -1, PREG_SPLIT_NO_EMPTY);\n            if ($arrn[0] !== '.') {\n                array_unshift($arrn, '.');\n            }\n            $arrn[0] = $base;\n            return join($separator, $arrn);\n        }\n\n        // Relative path from dirname()\n        if (substr($path, 0, 3) === '../') {\n            $arrn = preg_split($preg_separator, $path, -1, PREG_SPLIT_NO_EMPTY);\n            $arrp = preg_split($preg_separator, $base, -1, PREG_SPLIT_NO_EMPTY);\n\n            while (! empty($arrn) && $arrn[0] === '..') {\n                array_shift($arrn);\n                array_pop($arrp);\n            }\n            $path = ! empty($arrp) ? $systemroot . join($separator, array_merge($arrp, $arrn)) :\n                (! empty($arrn) ? $systemroot . join($separator, $arrn) : $systemroot);\n        }\n\n        return $path;\n    }\n\n    /**\n     * Remove directory recursive on local file system\n     *\n     * @param string $dir Target dirctory path\n     * @return boolean\n     * @author Naoki Sawada\n     */\n    public function rmdirRecursive($dir) {\n        if (!is_link($dir) && is_dir($dir)) {\n            @chmod($dir, 0777);\n            foreach (array_diff(scandir($dir), array('.', '..')) as $file) {\n                @set_time_limit(30);\n                $path = $dir . DIRECTORY_SEPARATOR . $file;\n                if (!is_link($dir) && is_dir($path)) {\n                    $this->rmdirRecursive($path);\n                } else {\n                    @chmod($path, 0666);\n                    @unlink($path);\n                }\n            }\n            return @rmdir($dir);\n        } else if (is_file($dir) || is_link($dir)) {\n            @chmod($dir, 0666);\n            return @unlink($dir);\n        }\n        return false;\n    }\n\n    /**\n     * Create archive and return its path\n     *\n     * @param  string  $dir    target dir\n     * @param  array   $files  files names list\n     * @param  string  $name   archive name\n     * @param  array   $arc    archiver options\n     * @return string|bool\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     * @author Naoki Sawada\n     **/\n    protected function makeArchive($dir, $files, $name, $arc) {\n        if ($arc['cmd'] === 'phpfunction') {\n            if (is_callable($arc['argc'])) {\n                call_user_func_array($arc['argc'], array($dir, $files, $name));\n            }\n        } else {\n            $cwd = getcwd();\n            chdir($dir);\n\n            $files = array_map('escapeshellarg', $files);\n\n            $cmd = $arc['cmd'].' '.$arc['argc'].' '.escapeshellarg($name).' '.implode(' ', $files);\n            $this->procExec($cmd, $o, $c);\n            chdir($cwd);\n        }\n        $path = $dir.DIRECTORY_SEPARATOR.$name;\n        return file_exists($path) ? $path : false;\n    }\n\n    /**\n     * Unpack archive\n     *\n     * @param  string  $path   archive path\n     * @param  array   $arc    archiver command and arguments (same as in $this->archivers)\n     * @param  bool    $remove remove archive ( unlink($path) )\n     * @return void\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     * @author Naoki Sawada\n     **/\n    protected function unpackArchive($path, $arc, $remove = true) {\n        $dir = dirname($path);\n        if ($arc['cmd'] === 'phpfunction') {\n            if (is_callable($arc['argc'])) {\n                call_user_func_array($arc['argc'], array($path, $dir));\n            }\n        } else {\n            $cwd = getcwd();\n            chdir($dir);\n            $cmd = $arc['cmd'].' '.$arc['argc'].' '.escapeshellarg(basename($path));\n            $this->procExec($cmd, $o, $c);\n            chdir($cwd);\n        }\n        $remove && unlink($path);\n    }\n\n    /**\n     * Create Zip archive using PHP class ZipArchive\n     *\n     * @param  string        $dir      target dir\n     * @param  array         $files    files names list\n     * @param  string|object $zipPath  Zip archive name\n     * @return void\n     * @author Naoki Sawada\n     */\n    protected static function zipArchiveZip($dir, $files, $zipPath) {\n        try {\n            if ($start = is_string($zipPath)) {\n                $zip = new \\ZipArchive();\n                if ($zip->open($dir . DIRECTORY_SEPARATOR . $zipPath, \\ZipArchive::CREATE) !== true) {\n                    $zip = false;\n                }\n            } else {\n                $zip = $zipPath;\n            }\n            if ($zip) {\n                foreach($files as $file) {\n                    $path = $dir . DIRECTORY_SEPARATOR . $file;\n                    if (is_dir($path)) {\n                        $zip->addEmptyDir($file);\n                        $_files = array();\n                        if ($handle = opendir($path)) {\n                            while (false !== ($entry = readdir($handle))) {\n                                if ($entry !== \".\" && $entry !== \"..\") {\n                                    $_files[] = $file . DIRECTORY_SEPARATOR . $entry;\n                                }\n                            }\n                            closedir($handle);\n                        }\n                        if ($_files) {\n                            self::zipArchiveZip($dir, $_files, $zip);\n                        }\n                    } else {\n                        $zip->addFile($path, $file);\n                    }\n                }\n                $start && $zip->close();\n            }\n        } catch (Exception $e) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Unpack Zip archive using PHP class ZipArchive\n     *\n     * @param  string $zipPath  Zip archive name\n     * @param  string $toDir    Extract to path\n     * @return bool\n     * @author Naoki Sawada\n     */\n    protected static function zipArchiveUnzip($zipPath, $toDir) {\n        try {\n            $zip = new \\ZipArchive();\n            if ($zip->open($zipPath) === true) {\n                $zip->extractTo($toDir);\n                $zip->close();\n            }\n        } catch (Exception $e) {\n            return false;\n        }\n        return true;\n    }\n\n    /**==================================* abstract methods *====================================**/\n\n    /*********************** paths/urls *************************/\n\n    /**\n     * Return parent directory path\n     *\n     * @param  string  $path  file path\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _dirname($path);\n\n    /**\n     * Return file name\n     *\n     * @param  string  $path  file path\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _basename($path);\n\n    /**\n     * Join dir name and file name and return full path.\n     * Some drivers (db) use int as path - so we give to concat path to driver itself\n     *\n     * @param  string  $dir   dir path\n     * @param  string  $name  file name\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _joinPath($dir, $name);\n\n    /**\n     * Return normalized path\n     *\n     * @param  string  $path  file path\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _normpath($path);\n\n    /**\n     * Return file path related to root dir\n     *\n     * @param  string  $path  file path\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _relpath($path);\n\n    /**\n     * Convert path related to root dir into real path\n     *\n     * @param  string  $path  rel file path\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _abspath($path);\n\n    /**\n     * Return fake path started from root dir.\n     * Required to show path on client side.\n     *\n     * @param  string  $path  file path\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _path($path);\n\n    /**\n     * Return true if $path is children of $parent\n     *\n     * @param  string  $path    path to check\n     * @param  string  $parent  parent path\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _inpath($path, $parent);\n\n    /**\n     * Return stat for given path.\n     * Stat contains following fields:\n     * - (int)    size    file size in b. required\n     * - (int)    ts      file modification time in unix time. required\n     * - (string) mime    mimetype. required for folders, others - optionally\n     * - (bool)   read    read permissions. required\n     * - (bool)   write   write permissions. required\n     * - (bool)   locked  is object locked. optionally\n     * - (bool)   hidden  is object hidden. optionally\n     * - (string) alias   for symlinks - link target path relative to root path. optionally\n     * - (string) target  for symlinks - link target path. optionally\n     *\n     * If file does not exists - returns empty array or false.\n     *\n     * @param  string  $path    file path\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _stat($path);\n\n\n    /***************** file stat ********************/\n\n\n    /**\n     * Return true if path is dir and has at least one childs directory\n     *\n     * @param  string  $path  dir path\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _subdirs($path);\n\n    /**\n     * Return object width and height\n     * Ususaly used for images, but can be realize for video etc...\n     *\n     * @param  string  $path  file path\n     * @param  string  $mime  file mime type\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _dimensions($path, $mime);\n\n    /******************** file/dir content *********************/\n\n    /**\n     * Return files list in directory\n     *\n     * @param  string  $path  dir path\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _scandir($path);\n\n    /**\n     * Open file and return file pointer\n     *\n     * @param  string $path file path\n     * @param  string $mode open mode\n     * @return resource|false\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _fopen($path, $mode=\"rb\");\n\n    /**\n     * Close opened file\n     *\n     * @param  resource  $fp    file pointer\n     * @param  string    $path  file path\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _fclose($fp, $path='');\n\n    /********************  file/dir manipulations *************************/\n\n    /**\n     * Create dir and return created dir path or false on failed\n     *\n     * @param  string  $path  parent dir path\n     * @param string  $name  new directory name\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _mkdir($path, $name);\n\n    /**\n     * Create file and return it's path or false on failed\n     *\n     * @param  string  $path  parent dir path\n     * @param string  $name  new file name\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _mkfile($path, $name);\n\n    /**\n     * Create symlink\n     *\n     * @param  string  $source     file to link to\n     * @param  string  $targetDir  folder to create link in\n     * @param  string  $name       symlink name\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _symlink($source, $targetDir, $name);\n\n    /**\n     * Copy file into another file (only inside one volume)\n     *\n     * @param  string  $source  source file path\n     * @param  string  $target  target dir path\n     * @param  string  $name    file name\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _copy($source, $targetDir, $name);\n\n    /**\n     * Move file into another parent dir.\n     * Return new file path or false.\n     *\n     * @param  string  $source  source file path\n     * @param  string  $target  target dir path\n     * @param  string  $name    file name\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _move($source, $targetDir, $name);\n\n    /**\n     * Remove file\n     *\n     * @param  string  $path  file path\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _unlink($path);\n\n    /**\n     * Remove dir\n     *\n     * @param  string  $path  dir path\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _rmdir($path);\n\n    /**\n     * Create new file and write into it from file pointer.\n     * Return new file path or false on error.\n     *\n     * @param  resource  $fp   file pointer\n     * @param  string    $dir  target dir path\n     * @param  string    $name file name\n     * @param  array     $stat file stat (required by some virtual fs)\n     * @return bool|string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _save($fp, $dir, $name, $stat);\n\n    /**\n     * Get file contents\n     *\n     * @param  string  $path  file path\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _getContents($path);\n\n    /**\n     * Write a string to a file\n     *\n     * @param  string  $path     file path\n     * @param  string  $content  new file content\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _filePutContents($path, $content);\n\n    /**\n     * Extract files from archive\n     *\n     * @param  string  $path file path\n     * @param  array   $arc  archiver options\n     * @return bool\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     **/\n    abstract protected function _extract($path, $arc);\n\n    /**\n     * Create archive and return its path\n     *\n     * @param  string  $dir    target dir\n     * @param  array   $files  files names list\n     * @param  string  $name   archive name\n     * @param  array   $arc    archiver options\n     * @return string|bool\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     **/\n    abstract protected function _archive($dir, $files, $name, $arc);\n\n    /**\n     * Detect available archivers\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     **/\n    abstract protected function _checkArchivers();\n\n    /**\n     * Change file mode (chmod)\n     *\n     * @param  string  $path  file path\n     * @param  string  $mode  octal string such as '0755'\n     * @return bool\n     * @author David Bartle,\n     **/\n    abstract protected function _chmod($path, $mode);\n\n\n} // END class\n",
			"file": "/home/roussillep/sandbox/todaycar/vendor/helios-ag/fm-elfinder-php-connector/src/Driver/ElFinderVolumeDriver.php",
			"file_size": 175289,
			"file_write_time": 131103066603401545,
			"settings":
			{
				"buffer_size": 175334,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/roussillep/sandbox/todaycar/vendor/helios-ag/fm-elfinder-php-connector/src/Driver/ElFinderVolumeLocalFileSystem.php",
			"settings":
			{
				"buffer_size": 37986,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Searching 109 files for \"dynamic\"\n\n/home/roussillep/sandbox/todaycar/vendor/faros/core-bundle/Resources/config/routing.yml:\n   10      options:\n   11          expose: true\n   12:         dynamic: false\n   13  \n\n/home/roussillep/sandbox/todaycar/vendor/faros/core-bundle/Resources/config/services.yml:\n    1  parameters:\n    2:     faros_core.dynamic_router_class: Faros\\CoreBundle\\Routing\\DynamicRouter\n    3:     faros.core.dynamic_route_generator_class: Faros\\CoreBundle\\Routing\\Rewriter\n    4      faros_core.user_provider_class: Faros\\CoreBundle\\Entity\\Repository\\UserRepository\n    5      faros_core.mailer_class: Faros\\CoreBundle\\Mail\\Mailer\n\n/home/roussillep/sandbox/todaycar/vendor/faros/core-bundle/Tests/Routing/DynamicRouterTest.php:\n    3  namespace Faros\\CoreBundle\\Tests\\Routing;\n    4  \n    5: use Faros\\CoreBundle\\Routing\\DynamicRouter;\n    6  use Mockery as m;\n    7  use Symfony\\Component\\HttpFoundation\\Request;\n    .\n    9  use Symfony\\Component\\Routing\\RouteCollection;\n   10  \n   11: class DynamicRouterTest extends \\PHPUnit_Framework_TestCase\n   12  {\n   13      private $router = null;\n   ..\n   33          $this->requestStack->shouldReceive('getCurrentRequest')->andReturn($request);\n   34  \n   35:         $this->router = new DynamicRouter($this->baseRouter, $registry, $this->requestStack, 'Route');\n   36      }\n   37  \n\n7 matches across 3 files\n",
			"settings":
			{
				"buffer_size": 1374,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"file": "/home/roussillep/sandbox/todaycar/vendor/faros/core-bundle/Resources/config/routing.yml",
			"settings":
			{
				"buffer_size": 340,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/roussillep/sandbox/todaycar/src/AdminBundle/Menu/Builder.php",
			"settings":
			{
				"buffer_size": 3672,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/roussillep/sandbox/todaycar/vendor/faros/seo-bundle/Routing/Router.php",
			"settings":
			{
				"buffer_size": 5701,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "source_dir: %kernel.root_dir%/Resources/exchange/in\nidentifier: StockTrusty\n\nresources:\n    StockTrusty:\n        tablename: __tmp_stock_trusty\n        load:\n            pattern: \"^StockTrusty.csv\"\n            format_options:\n                field_delimiter: ';'\n                line_delimiter: '\\r\\n'\n                validate_headers: true\n            fields:\n                'CarnetEntretien': ~\n                'Carrosserie': ~\n                'Clefs': ~\n                'Co2': ~\n                'commentaire produit': text\n                'consommation euromix': ~\n                'Cote ArgusAnnonces': ~\n                'Couleur': ~\n                'cylindree': ~\n                'Date1MEC': ~\n                'DateCreation': ~\n                'DateExpirationGC': ~\n                'DateMission': ~\n                'DossierRefInt': integer\n                'empattement': integer\n                'Energie': ~\n                'Equipements': text\n                'Etat': ~\n                'GarantieConstructeur': integer\n                'Genre': ~\n                'Hauteur': integer\n                'Immatriculation': ~\n                'kilo declare': ~\n                'Largeur': ~\n                'lien expertise': text\n                'Longueur': ~\n                'Marque': ~\n                'Millesime': integer\n                'NbCylind': integer\n                'NbPortes': integer\n                'NbVitesses': integer\n                'NE': integer\n                'observations': ~\n                'PAV': integer\n                'photos': text\n                'Places': ~\n                'PremiereMain': ~\n                'prix de vente': ~\n                'PrixNeuf': ~\n                'Propulsion': ~\n                'Puissance': integer\n                'PuissanceCh': integer\n                'Regroupement': ~\n                'Segment': ~\n                'TPBoiteVit': ~\n                'TypeComm': ~\n                'volume coffre': ~\n                'XCle': ~\n                'dossierrefvendeur': integer\n            extra_fields:\n                created_by:\n                    options:\n                        default: Import\n                created_at:\n                    type: datetime\n                status:\n                    options:\n                        default: published\n                publish_end:\n                    type: datetime\n                champ_supll:\n                    type: string\n\n    brand:\n        tablename: __tmp_stock_trusty\n        copy:\n            target: brand\n            strategy: insert_or_update\n            strategy_options:\n                non_updateable_fields: [created_at, created_by]\n                copy_condition: |\n                    1 = 1 GROUP BY marque, status, created_at, created_by\n            mapping:\n                marque: 'title'\n                status: 'status'\n                created_at:\n                    property: [created_at, updated_at, publish_start]\n                created_by:\n                    property: [created_by, updated_by]\n\n    ad:\n        tablename: __tmp_stock_trusty\n        copy:\n            target: ad\n            strategy: insert_or_update\n            strategy_options:\n                non_updateable_fields: [created_at, created_by, status]\n            mapping:\n                publish_end: 'publish_end'\n                status: 'status'\n                dossierrefint: 'dossier_ref_int'\n                typecomm: 'type_comm'\n                carnetentretien: 'carnet_entretien'\n                clefs: 'clefs'\n                carrosserie: 'carrosserie'\n                co2: 'co2'\n                commentaire_produit: 'commentaire_produit'\n                consommation_euromix: 'consommation_euromix'\n                cote_argusannonces: 'cote_argus_annonces'\n                couleur: 'couleur'\n                cylindree: 'cylindree'\n                date1mec: 'date1mec'\n                datecreation: 'date_creation'\n                dateexpirationgc: 'date_expiration_gc'\n                datemission: 'date_mission'\n                empattement: 'empattement'\n                energie: 'energie'\n                etat: 'etat'\n                garantieconstructeur: 'garantie_constructeur'\n                genre: 'genre'\n                immatriculation: 'immatriculation'\n                hauteur: 'hauteur'\n                largeur: 'largeur'\n                longueur: 'longueur'\n                kilo_declare: 'kilo_declare'\n                lien_expertise: 'lien_expertise'\n                marque: 'marque'\n                millesime: 'millesime'\n                nbcylind: 'nb_cylind'\n                nbportes: 'nb_portes'\n                nbvitesses: 'nb_vitesses'\n                ne: 'norme_euro'\n                observations: 'observations'\n                pav: 'pav'\n                places: 'places'\n                premieremain: 'premiere_main'\n                prix_de_vente: 'prix_de_vente'\n                prixneuf: 'prix_neuf'\n                propulsion: 'propulsion'\n                puissance: 'puissance'\n                puissancech: 'puissance_ch'\n                regroupement: 'regroupement'\n                segment: 'segment'\n                tpboitevit: 'tpboite_vit'\n                volume_coffre: 'volume_coffre'\n                xcle: 'xcle'\n                equipements: 'import_equipments'\n                photos: 'import_photos'\n                'dossierrefvendeur': 'dossier_ref_vendeur'\n                created_at:\n                    property: [created_at, updated_at, publish_start]\n                created_by:\n                    property: [created_by, updated_by]\n",
			"file": "/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/config/import/stockTrusty.yml",
			"file_size": 5522,
			"file_write_time": 131184002979765931,
			"settings":
			{
				"buffer_size": 5584,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/roussillep/sandbox/todaycar/src/SiteBundle/Import/AdListener.php",
			"settings":
			{
				"buffer_size": 11527,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/roussillep/sandbox/todaycar/app/config/roles.yml",
			"settings":
			{
				"buffer_size": 3940,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/roussillep/sandbox/todaycar/vendor/helios-ag/fm-elfinder-bundle/Tests/DependencyInjection/ConfigurationLoadTest.php",
			"settings":
			{
				"buffer_size": 6532,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/roussillep/sandbox/todaycar/vendor/helios-ag/fm-elfinder-bundle/DependencyInjection/Configuration.php",
			"settings":
			{
				"buffer_size": 24001,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 357.0,
		"last_filter": "move",
		"selected_items":
		[
			[
				"move",
				"File: Move"
			],
			[
				"upper",
				"Convert Case: Upper Case"
			],
			[
				"boxy",
				"Boxy Theme: Activation"
			],
			[
				"theme",
				"Boxy Theme: Preferences"
			],
			[
				"blame",
				"Git: Blame"
			],
			[
				"thmee",
				"Themr: List themes"
			],
			[
				"thme",
				"Themr: List themes"
			],
			[
				"json",
				"JSON Reindent: reindent file or selection"
			],
			[
				"scheme",
				"ColorSchemeSelector: Select Color Scheme"
			],
			[
				"packa",
				"Package Control: List Packages"
			],
			[
				"sche",
				"ColorSchemeSelector: Select Color Scheme"
			],
			[
				"schele",
				"ColorSchemeSelector: Select Color Scheme"
			],
			[
				"rei",
				"Indentation: Reindent Lines"
			],
			[
				"reid",
				"Indentation: Reindent Lines"
			]
		],
		"width": 575.0
	},
	"console":
	{
		"height": 391.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/roussillep/sandbox/todaycar",
		"/home/roussillep/sandbox/todaycar/app",
		"/home/roussillep/sandbox/todaycar/app/config",
		"/home/roussillep/sandbox/todaycar/app/config/capistrano",
		"/home/roussillep/sandbox/todaycar/app/config/capistrano/stages",
		"/home/roussillep/sandbox/todaycar/app/config/capistrano/tasks",
		"/home/roussillep/sandbox/todaycar/src",
		"/home/roussillep/sandbox/todaycar/src/AdminBundle",
		"/home/roussillep/sandbox/todaycar/src/AdminBundle/Resources",
		"/home/roussillep/sandbox/todaycar/src/AdminBundle/Resources/config",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Controller",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Import",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/config",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/config/import",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/fixtures",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/public",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/views",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/views/Email",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/views/Email/fr",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/views/Email/fr/Booking",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/views/Email/fr/Form",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/views/Email/fr/Form/Admin",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/views/Email/fr/Form/User",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/views/Email/fr/Sell",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Search",
		"/home/roussillep/sandbox/todaycar/vendor",
		"/home/roussillep/sandbox/todaycar/vendor/faros",
		"/home/roussillep/sandbox/todaycar/web",
		"/home/roussillep/sandbox/todaycar/web/compiled"
	],
	"file_history":
	[
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/config/validation.yml",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Form/SellInquiryType.php",
		"/home/roussillep/sandbox/todaycar/vendor/faros/avant-theme-bundle/Controller/Admin/SecurityController.php",
		"/home/roussillep/sandbox/todaycar/vendor/faros/core-bundle/Entity/Repository/UserRepository.php",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Import/AdListener.php",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Entity/Ad/Ad.php",
		"/home/roussillep/sandbox/todaycar/app/Resources/exchange/in/StockTrusty.csv",
		"/home/roussillep/sandbox/todaycar/app/Resources/crontab.production",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Controller/ContactInspectorController.php",
		"/home/roussillep/sandbox/todaycar/vendor/faros/lead-bundle/Controller/AbstractFormController.php",
		"/home/roussillep/sandbox/todaycar/app/config/roles.yml",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/config/routing.yml",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Command/AdBookingCleanupCommand.php",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Search/Index.php",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Command/ElasticSearchPopulateCommand.php",
		"/home/roussillep/sandbox/todaycar/app/config/parameters.yml",
		"/home/roussillep/sandbox/todaycar/vendor/helios-ag/fm-elfinder-php-connector/src/Driver/ElFinderVolumeLocalFileSystem.php",
		"/home/roussillep/sandbox/todaycar/vendor/helios-ag/fm-elfinder-bundle/Tests/DependencyInjection/ConfigurationLoadTest.php",
		"/home/roussillep/sandbox/todaycar/vendor/symfony/symfony/src/Symfony/Component/Config/Util/XmlUtils.php",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/views/Ads/show.html.twig",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/views/Ads/_rapport.html.twig",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Form/SellInquiryFlow.php",
		"/home/roussillep/sandbox/todaycar/src/AdminBundle/Controller/SellLandingPageController.php",
		"/home/roussillep/sandbox/todaycar/vendor/faros/admin-bundle/Controller/CRUD/ORMController.php",
		"/home/roussillep/sandbox/todaycar/vendor/faros/core-bundle/Publication/PublicationManager.php",
		"/home/roussillep/sandbox/todaycar/src/AdminBundle/Controller/AdController.php",
		"/home/roussillep/sandbox/todaycar/src/AdminBundle/Controller/ContactInspectorController.php",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Controller/SellInquiryController.php",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Entity/Repository/SellLandingPageRepository.php",
		"/home/roussillep/sandbox/todaycar/app/DoctrineMigrations/Version20161212112131.php",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Entity/Page/SellLandingPage.php",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/views/Contact/Form/sell_inquiry.html.twig",
		"/home/roussillep/sandbox/todaycar/src/AdminBundle/Resources/views/SellLandingPage/form.html.twig",
		"/home/roussillep/sandbox/todaycar/src/AdminBundle/Resources/translations/messages.fr.yml",
		"/home/roussillep/sandbox/todaycar/src/AdminBundle/Form/SellLandingPageType.php",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Controller/AdController.php",
		"/home/roussillep/sandbox/todaycar/app/config/config.yml",
		"/home/roussillep/sandbox/todaycar/src/AdminBundle/Controller/SellInquiryController.php",
		"/home/roussillep/sandbox/todaycar/web/.htaccess",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/views/Contact/Form/sell_inquiry_confirm.html.twig",
		"/home/roussillep/sandbox/todaycar/vendor/faros/avant-theme-bundle/Resources/views/themes/avant/Email/request-password.html.twig",
		"/home/roussillep/sandbox/todaycar/vendor/faros/core-bundle/Resources/skeleton/Entity/User.php",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Entity/Core/User.php",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Controller/InquiryController.php",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/views/Contact/Form/sell_inquiry_layout.html.twig",
		"/home/roussillep/sandbox/brithotel/src/BritHotel/ExtranetBundle/Controller/Price/GroupRateController.php",
		"/home/roussillep/sandbox/renoval/var/logs/dev.inquiry_api.log",
		"/home/roussillep/sandbox/renoval/src/ExtranetBundle/Form/Type/DealerProfileType.php",
		"/home/roussillep/sandbox/renoval/src/ExtranetBundle/Entity/Cms/Repository/NewsRepository.php",
		"/home/roussillep/sandbox/renoval/src/ExtranetBundle/Controller/DashboardController.php",
		"/home/roussillep/sandbox/renoval/src/ExtranetBundle/Entity/Core/DealerProfile.php",
		"/home/roussillep/sandbox/renoval/web/bundles/extranet/less/theme.less",
		"/home/roussillep/sandbox/renoval/src/ExtranetBundle/Controller/Lead/InquiryController.php",
		"/home/roussillep/sandbox/renoval/src/ExtranetBundle/Controller/Core/DealerController.php",
		"/home/roussillep/sandbox/renoval/app/DoctrineMigrations/Version20161201153121.php",
		"/home/roussillep/sandbox/renoval/app/DoctrineMigrations/Version20161201152949.php",
		"/home/roussillep/sandbox/renoval/var/logs/dev.dealer_api.log",
		"/home/roussillep/sandbox/renoval/src/ExtranetBundle/Resources/views/Core/Dealer/list.html.twig",
		"/home/roussillep/sandbox/renoval/app/config/config.yml",
		"/home/roussillep/sandbox/renoval/app/config/config_dev.yml",
		"/home/roussillep/sandbox/renoval/app/config/config_prod.yml",
		"/home/roussillep/sandbox/renoval/vendor/faros/avant-theme-bundle/Resources/views/themes/avant/base.html.twig",
		"/home/roussillep/sandbox/renoval/src/ExtranetBundle/Menu/Builder.php",
		"/home/roussillep/sandbox/renoval/src/ExtranetBundle/Resources/config/services.yml",
		"/home/roussillep/sandbox/renoval/vendor/faros/avant-theme-bundle/Menu/DefaultMenuBuilder.php",
		"/home/roussillep/sandbox/renoval/src/ExtranetBundle/Resources/views/layout.html.twig",
		"/home/roussillep/sandbox/renoval/src/ExtranetBundle/Resources/public/less/theme.less",
		"/home/roussillep/sandbox/renoval/web/bundles/farosavanttheme/themes/avant/less/bootstrap-avanttheme.less",
		"/home/roussillep/sandbox/renoval/web/bundles/farosavanttheme/themes/avant/libs/less/variables.less",
		"/home/roussillep/sandbox/renoval/src/ExtranetBundle/Resources/views/Menu/main.html.twig",
		"/home/roussillep/sandbox/renoval/vendor/knplabs/knp-menu/src/Knp/Menu/Resources/views/knp_menu.html.twig",
		"/home/roussillep/sandbox/renoval/web/bundles/farosavanttheme/themes/avant/js/admin.js",
		"/home/roussillep/sandbox/renoval/web/bundles/farosavanttheme/themes/avant/libs/js/application.js",
		"/home/roussillep/sandbox/renoval/vendor/faros/avant-theme-bundle/Resources/config/services.yml",
		"/home/roussillep/sandbox/renoval/src/ExtranetBundle/Menu/DefaultMenuBuilder.php",
		"/home/roussillep/sandbox/renoval/vendor/faros/avant-theme-bundle/Resources/views/themes/avant/Menu/main.html.twig",
		"/home/roussillep/sandbox/bernard-solfin/docker-compose.override.yml",
		"/home/roussillep/sandbox/bernard-solfin/src/BernardSolfin/AdminBundle/Controller/Catalog/CatalogController.php",
		"/home/roussillep/sandbox/bernard-solfin/vendor/faros/catalog-bundle/Faros/CatalogBundle/Controller/CatalogController.php",
		"/home/roussillep/sandbox/bernard-solfin/src/BernardSolfin/SiteBundle/Controller/CatalogController.php",
		"/home/roussillep/sandbox/bernard-solfin/src/BernardSolfin/SiteBundle/Controller/CommonsController.php",
		"/home/roussillep/sandbox/bernard-solfin/app/config/parameters.yml",
		"/home/roussillep/sandbox/todaycar/var/logs/dev-2016-06-14.log",
		"/home/roussillep/sandbox/todaycar/Gemfile",
		"/home/roussillep/sandbox/todaycar/Capfile",
		"/home/roussillep/sandbox/todaycar/app/config/capistrano/deploy.rb",
		"/home/roussillep/sandbox/todaycar/app/config/capistrano/tasks/secure.rake",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/public/js/theia-sticky-sidebar.js",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/views/layout.html.twig",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/views/Booking/recapitulatif.html.twig",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/views/Booking/livraison.html.twig",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/views/Ads/index.html.twig",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/views/Booking/_recap_final.html.twig",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/public/less/responsive.less",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/public/less/styleDev.less",
		"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/public/js/script.js",
		"/home/roussillep/sandbox/todaycar/gulpfile.js",
		"/home/roussillep/gnome-terminal-colors-solarized/set_dark.sh",
		"/home/roussillep/.config/dconf/user",
		"/home/roussillep/sandbox/todaycar/vendor/bower_components/theia-sticky-sidebar/js/theia-sticky-sidebar.js",
		"/home/roussillep/sandbox/todaycar/package.json",
		"/home/roussillep/sandbox/todaycar/docker-compose.override.yml.dist",
		"/home/roussillep/sandbox/todaycar/docker-compose.yml",
		"/home/roussillep/sandbox/todaycar/docker-compose.override.yml",
		"/home/roussillep/sandbox/todaycar/app/config/parameters.yml.dist",
		"/home/roussillep/.dotfiles/.tmux.conf"
	],
	"find":
	{
		"height": 48.0
	},
	"find_in_files":
	{
		"height": 90.0,
		"where_history":
		[
			"/home/roussillep/sandbox/todaycar/vendor/faros/core-bundle",
			"/home/roussillep/sandbox/todaycar/vendor/faros",
			"/home/roussillep/sandbox/todaycar/vendor/helios-ag",
			"/home/roussillep/sandbox/todaycar/src",
			"/home/roussillep/sandbox/todaycar/src/AdminBundle/Controller",
			"/home/roussillep/sandbox/todaycar/src",
			"/home/roussillep/sandbox/todaycar/src/SiteBundle/Entity",
			"/home/roussillep/sandbox/todaycar/vendor/faros/avant-theme-bundle",
			"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/views",
			"/home/roussillep/sandbox/renoval/src/ExtranetBundle/Entity",
			"/home/roussillep/sandbox/renoval/src/ExtranetBundle/Entity/Core",
			"/home/roussillep/sandbox/renoval/web/bundles/farosavanttheme/themes/avant/libs/js",
			"/home/roussillep/sandbox/renoval/web/bundles/farosavanttheme/themes/avant/js",
			"/home/roussillep/sandbox/renoval/vendor/faros",
			"/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/public/less"
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"scheme",
			"session",
			"dynamic",
			"quarantine",
			"quaran",
			"fileMode",
			"$this->options",
			"fileMode",
			"644",
			"0644",
			"tmb",
			"fileMode",
			"tmb",
			"fileMode",
			"tmb_path",
			"tmb_path_mode",
			"tmb",
			"fileMode",
			"\n",
			",",
			"INSPE",
			"macadam_assessment",
			"updateAssessmentQuery",
			"transmission",
			"macadam_assessment",
			"experti",
			"landing",
			"filter",
			"dump",
			"themes/avant/libs/",
			"step_order",
			"backgroundPosition",
			"BackgroundPosition",
			"backgroundPosition",
			"BackgroundPosition",
			"backgroundPosition",
			"BackgroundPosition",
			"default",
			"backgroundPosition",
			"'validation_groups' => ",
			"setp_",
			"flow_sellInquiry_step2",
			"flow_sellInquiry_step1",
			"step",
			"faros_avant_theme.admin.request_password.email",
			"request-password",
			"google_conversion_id",
			"boolean",
			"Enabled",
			"enabled",
			"Enabled",
			"enabled",
			"dealer",
			"acc-menu",
			".show",
			"nav",
			"display",
			"display:",
			"#d2d3d6",
			"display",
			"acc-menu",
			"hasChild",
			"DefaultMenuBuilder",
			"isProductPublished",
			"$this->pm",
			"disabled",
			"\n        $suggest = count($params) > 0 ? $index->suggest($params) : [];",
			"\n        $suggestAds = array_column($suggest['hits']['hits'], '_source', '_id');",
			"\n        $suggest = $index->suggest($params);",
			"brand",
			"model",
			"\n                                'boost' => 1,",
			"boots",
			"booots",
			":",
			"}",
			"{",
			"$page * 5",
			"cross",
			"awl",
			"awol",
			"ads",
			"Envoyez nous un email",
			"blocAnnonce",
			"#pageShowAd .blocAnnonce",
			"fixPrice",
			"infoprix",
			"trustycar",
			"target_base"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 6,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "/home/roussillep/sandbox/todaycar/vendor/helios-ag/fm-elfinder-php-connector/src/Driver/ElFinderVolumeDriver.php",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 175334,
						"regions":
						{
						},
						"selection":
						[
							[
								118077,
								118077
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
									"1":
									[
										118093,
										118094
									]
								},
								"icon":
								{
									"1":
									[
										"Packages/BracketHighlighter/icons/square_bracket.png",
										"brackethighlighter.default"
									]
								},
								"open":
								{
									"1":
									[
										118077,
										118078
									]
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content"
							],
							"editorconfig": true,
							"ensure_newline_at_eof_on_save": true,
							"syntax": "Packages/PHP/PHP.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true,
							"trim_trailing_white_space_on_save": true
						},
						"translation.x": 0.0,
						"translation.y": 52398.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "/home/roussillep/sandbox/todaycar/vendor/helios-ag/fm-elfinder-php-connector/src/Driver/ElFinderVolumeLocalFileSystem.php",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 37986,
						"regions":
						{
						},
						"selection":
						[
							[
								30242,
								30250
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
									"1":
									[
										30262,
										30263
									]
								},
								"icon":
								{
									"1":
									[
										"Packages/BracketHighlighter/icons/round_bracket.png",
										"brackethighlighter.default"
									]
								},
								"open":
								{
									"1":
									[
										30250,
										30251
									]
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content"
							],
							"editorconfig": true,
							"ensure_newline_at_eof_on_save": true,
							"syntax": "Packages/PHP/PHP.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true,
							"trim_trailing_white_space_on_save": true
						},
						"translation.x": 0.0,
						"translation.y": 13989.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 2,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1374,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										187,
										194
									],
									[
										342,
										349
									],
									[
										389,
										396
									],
									[
										425,
										432
									],
									[
										838,
										845
									],
									[
										1012,
										1019
									],
									[
										1252,
										1259
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								192,
								192
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content"
							],
							"default_dir": "/home/roussillep/sandbox/todaycar",
							"detect_indentation": false,
							"line_numbers": false,
							"output_tag": 1,
							"result_base_dir": "",
							"result_file_regex": "^([^ \t].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "/home/roussillep/sandbox/todaycar/vendor/faros/core-bundle/Resources/config/routing.yml",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 340,
						"regions":
						{
						},
						"selection":
						[
							[
								340,
								340
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content"
							],
							"editorconfig": true,
							"ensure_newline_at_eof_on_save": true,
							"syntax": "Packages/YAML/YAML.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true,
							"trim_trailing_white_space_on_save": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "/home/roussillep/sandbox/todaycar/src/AdminBundle/Menu/Builder.php",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3672,
						"regions":
						{
						},
						"selection":
						[
							[
								1117,
								1117
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
									"1":
									[
										1122,
										1123
									]
								},
								"icon":
								{
									"1":
									[
										"Packages/BracketHighlighter/icons/curly_bracket.png",
										"brackethighlighter.default"
									]
								},
								"open":
								{
									"1":
									[
										229,
										230
									]
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content"
							],
							"editorconfig": true,
							"ensure_newline_at_eof_on_save": true,
							"syntax": "Packages/PHP/PHP.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true,
							"trim_trailing_white_space_on_save": true
						},
						"translation.x": 0.0,
						"translation.y": 75.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "/home/roussillep/sandbox/todaycar/vendor/faros/seo-bundle/Routing/Router.php",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5701,
						"regions":
						{
						},
						"selection":
						[
							[
								3096,
								3096
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content"
							],
							"color_helper.box_height": 15,
							"color_helper.color_scheme": "Packages/Boxy Theme/schemes/Boxy Solarized Light.tmTheme",
							"color_helper.file_palette":
							[
							],
							"color_helper.scan":
							{
								"current_ext": ".php",
								"current_syntax": "PHP/PHP",
								"enabled": false,
								"last_updated": 1501144820.52
							},
							"editorconfig": true,
							"ensure_newline_at_eof_on_save": true,
							"syntax": "Packages/PHP/PHP.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true,
							"trim_trailing_white_space_on_save": true
						},
						"translation.x": 0.0,
						"translation.y": 810.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "/home/roussillep/sandbox/todaycar/src/SiteBundle/Resources/config/import/stockTrusty.yml",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5584,
						"regions":
						{
						},
						"selection":
						[
							[
								2301,
								2301
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content"
							],
							"color_helper.box_height": 15,
							"color_helper.color_scheme": "Packages/Boxy Theme/schemes/Boxy Solarized Light.tmTheme",
							"color_helper.file_palette":
							[
							],
							"color_helper.preview_meta":
							{
							},
							"color_helper.scan":
							{
								"current_ext": ".yml",
								"current_syntax": "YAML/YAML",
								"enabled": false,
								"last_updated": 1501226907.63
							},
							"editorconfig": true,
							"ensure_newline_at_eof_on_save": true,
							"syntax": "Packages/YAML/YAML.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true,
							"trim_trailing_white_space_on_save": true
						},
						"translation.x": 0.0,
						"translation.y": 624.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "/home/roussillep/sandbox/todaycar/src/SiteBundle/Import/AdListener.php",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11527,
						"regions":
						{
						},
						"selection":
						[
							[
								2369,
								2369
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
									"1":
									[
										2368,
										2369
									]
								},
								"icon":
								{
									"1":
									[
										"Packages/BracketHighlighter/icons/round_bracket.png",
										"brackethighlighter.default"
									]
								},
								"open":
								{
									"1":
									[
										2307,
										2308
									]
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content"
							],
							"color_helper.box_height": 15,
							"color_helper.color_scheme": "Packages/Boxy Theme/schemes/Boxy Solarized Light.tmTheme",
							"color_helper.file_palette":
							[
							],
							"color_helper.scan":
							{
								"allowed_colors":
								[
									"webcolors",
									"rgba",
									"rgb",
									"hex",
									"hsla",
									"hex_compressed",
									"hsl"
								],
								"compress_hex_output": true,
								"current_ext": ".php",
								"current_syntax": "PHP/PHP",
								"enabled": true,
								"last_updated": 1501144820.52,
								"scan_completion_scopes":
								[
								],
								"scan_scopes":
								[
									"meta.declaration-list.css -support.type.property-name.css -comment -string",
									"meta.property-value.css -comment -string",
									"meta.value.css -comment -string",
									"meta.tag.inline.any.html string.quoted -constant.character.entity.html",
									"meta.tag.any.html meta.attribute-with-value.style.html"
								],
								"use_hex_argb": false
							},
							"editorconfig": true,
							"ensure_newline_at_eof_on_save": true,
							"syntax": "Packages/PHP/PHP.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true,
							"trim_trailing_white_space_on_save": true
						},
						"translation.x": 0.0,
						"translation.y": 540.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "/home/roussillep/sandbox/todaycar/app/config/roles.yml",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3940,
						"regions":
						{
						},
						"selection":
						[
							[
								466,
								466
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
									"1":
									[
										465,
										466
									]
								},
								"icon":
								{
									"1":
									[
										"Packages/BracketHighlighter/icons/curly_bracket.png",
										"brackethighlighter.default"
									]
								},
								"open":
								{
									"1":
									[
										398,
										399
									]
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content"
							],
							"editorconfig": true,
							"ensure_newline_at_eof_on_save": true,
							"syntax": "Packages/YAML/YAML.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true,
							"trim_trailing_white_space_on_save": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "/home/roussillep/sandbox/todaycar/vendor/helios-ag/fm-elfinder-bundle/Tests/DependencyInjection/ConfigurationLoadTest.php",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6532,
						"regions":
						{
						},
						"selection":
						[
							[
								3697,
								3697
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
									"1":
									[
										3697,
										3698
									]
								},
								"icon":
								{
									"1":
									[
										"Packages/BracketHighlighter/icons/single_quote.png",
										"brackethighlighter.default"
									]
								},
								"open":
								{
									"1":
									[
										3688,
										3689
									]
								},
								"unmatched":
								{
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content"
							],
							"editorconfig": true,
							"ensure_newline_at_eof_on_save": true,
							"syntax": "Packages/PHP/PHP.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true,
							"trim_trailing_white_space_on_save": true
						},
						"translation.x": 0.0,
						"translation.y": 723.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "/home/roussillep/sandbox/todaycar/vendor/helios-ag/fm-elfinder-bundle/DependencyInjection/Configuration.php",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 24001,
						"regions":
						{
						},
						"selection":
						[
							[
								1208,
								1208
							]
						],
						"settings":
						{
							"bracket_highlighter.busy": false,
							"bracket_highlighter.locations":
							{
								"close":
								{
								},
								"icon":
								{
								},
								"open":
								{
								},
								"unmatched":
								{
									"1":
									[
										676,
										677
									]
								}
							},
							"bracket_highlighter.regions":
							[
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content"
							],
							"editorconfig": true,
							"ensure_newline_at_eof_on_save": true,
							"syntax": "Packages/PHP/PHP.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true,
							"trim_trailing_white_space_on_save": true
						},
						"translation.x": 0.0,
						"translation.y": 48.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 26.0
	},
	"input":
	{
		"height": 31.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "todaycar.sublime-project",
	"replace":
	{
		"height": 48.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"router.",
				"vendor/faros/seo-bundle/Routing/Router.php"
			],
			[
				"menubuilder",
				"src/AdminBundle/Menu/Builder.php"
			],
			[
				"adbooki",
				"src/SiteBundle/Command/AdBookingCleanupCommand.php"
			],
			[
				"crontab",
				"app/Resources/crontab.production"
			],
			[
				"ad.php",
				"src/SiteBundle/Entity/Ad/Ad.php"
			],
			[
				"index.php",
				"src/SiteBundle/Search/Index.php"
			],
			[
				"xmlutils",
				"vendor/symfony/symfony/src/Symfony/Component/Config/Util/XmlUtils.php"
			],
			[
				"securitycontro",
				"vendor/faros/avant-theme-bundle/Controller/Admin/SecurityController.php"
			],
			[
				"publi",
				"vendor/faros/core-bundle/Publication/PublicationManager.php"
			],
			[
				"landincntroller",
				"src/AdminBundle/Controller/SellLandingPageController.php"
			],
			[
				"selllandingre",
				"src/SiteBundle/Entity/Repository/SellLandingPageRepository.php"
			],
			[
				"selllandingpagerepo",
				"src/SiteBundle/Entity/Repository/SellLandingPageRepository.php"
			],
			[
				"selllandingtype",
				"src/AdminBundle/Form/SellLandingPageType.php"
			],
			[
				"sellinquicontroller",
				"src/SiteBundle/Controller/SellInquiryController.php"
			],
			[
				"user.php",
				"src/SiteBundle/Entity/Core/User.php"
			],
			[
				"emailpassword",
				"vendor/faros/avant-theme-bundle/Resources/views/themes/avant/Email/request-password.html.twig"
			],
			[
				".htacecss",
				"web/.htaccess"
			],
			[
				"dealerryp",
				"src/ExtranetBundle/Form/Type/DealerProfileType.php"
			],
			[
				"dealerprofile",
				"src/ExtranetBundle/Entity/Core/DealerProfile.php"
			],
			[
				"theme.less",
				"web/bundles/extranet/less/theme.less"
			],
			[
				"inquicontroller",
				"src/ExtranetBundle/Controller/Lead/InquiryController.php"
			],
			[
				"varlogsdealer",
				"var/logs/dev.dealer_api.log"
			],
			[
				"dealercontroller",
				"src/ExtranetBundle/Controller/Core/DealerController.php"
			],
			[
				"defaultmenubuilder",
				"vendor/faros/avant-theme-bundle/Menu/DefaultMenuBuilder.php"
			],
			[
				"admin.js",
				"web/bundles/farosavanttheme/themes/avant/js/admin.js"
			],
			[
				"knpmenuhtml",
				"vendor/knplabs/knp-menu/src/Knp/Menu/Resources/views/knp_menu.html.twig"
			],
			[
				"default",
				"src/ExtranetBundle/Menu/DefaultMenuBuilder.php"
			],
			[
				"bootstrap-avanttheme.less",
				"web/bundles/farosavanttheme/themes/avant/less/bootstrap-avanttheme.less"
			],
			[
				"knp_menu.html",
				"vendor/knplabs/knp-menu/src/Knp/Menu/Resources/views/knp_menu.html.twig"
			],
			[
				"main.html.tw",
				"vendor/faros/avant-theme-bundle/Resources/views/themes/avant/Menu/main.html.twig"
			],
			[
				"avantbase.html.twi",
				"vendor/faros/avant-theme-bundle/Resources/views/themes/avant/base.html.twig"
			],
			[
				"catalogcontroller",
				"src/BernardSolfin/SiteBundle/Controller/CatalogController.php"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "ponroy",
		"selected_items":
		[
			[
				"ponroy",
				"~/sandbox/ponroy.sublime-workspace"
			],
			[
				"",
				"~/sandbox/dotfiles.sublime-workspace"
			]
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": false,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 251.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
